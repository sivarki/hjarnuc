{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"User Manual (Forge Networking Remastered) Welcome to Forge Networking Remastered, we would like to personally thank you for electing to become a part of our journey into Networking systems and Software as a whole. You are here because you have become a premium supporter of the Forge Networking project! Here for the Code API ? Here for the Video Tutorials ? Forge Networking to Remastered Migration Guide First, we would like to thank you so much for supporting Forge Networking over the past two years and we are proud to bring you Forge Networking Remastered ! Forge Networking Remastered (FNR) is a re-imagining of networking for Forge. We took everything we learned, all the feedback we could get and we started from scratch on FNR. We kept some of the helper classes such as ObjectMapper and BMSByte as those were optimized classes just for generic network data transfer. Secondly, we started FNR with the thought of Web Sockets and WebGL in mind. Though (at the time of this writing) WebGL support is not officially complete, we are working very hard to solidify this platform (mainly in relation to Unity integration and limitations). Thirdly we wanted to completely remove any kind of reflection \"magic\" that was in the system. In place of reflection we opted for generated class files and code, this makes debugging and tracking execution much easier to maintain and test. Now for the reveal of the biggest change to Forge Networking, the Network Object. We have replaced the old singular, monolithic inheritance network model in place of an attachment network model. Now you can write your code as you wish without overly intrusive and complicated code/reflection and have a more solid extendable model. We have also included the new Network Contract Wizard (NCW) which allows you to easily blueprint and review your network contracts without having to dig through tons of code. We have completely re-imagined networking to be more of a service, attachment, addon, and extension rather than an overly complex integrated model. Of course you will find many things that you once knew such as Network Instantiation , Remote Procedure Calls RPC , MainThreadManager ( Threading in Unity ) however you will find that some of the older models (such as NetSync ) have been removed. I know, I know, NetSync is awesome and it works kinda like UNET's SyncVar ; however, we believe we have a much simpler, more controlled, less magical, and more powerful approach to serializing network variables. Since we have abstracted all the network code to be an attachment, you will find a new fancy network Object variable that is a part of the class you create. This object will house all of your network variables and allow you to set the sync time as well as access any variable from the network easily. This means you can choose when to use the network variable, choices are good, yes? Also, the networkObject is powerful, it automatically detects changes to your variable (as a whole) and serializes only that variable as opposed to the whole network class! So, what are the difference highlights? Instantiation is done through NetworkManager.Instance.Instantiate... Remote procedure calls are done through networkObject.SendRpc NetSync has become networkObject.[myVar] PrimarySocket has become NetworkManager.Instance.Networker (You can also get the networker from the networkObject ) WriteCustom has become Binary (Check out the VOIP module for how to use Binary) Networking and NetworkingManager have been replaced by NetworkManager So what are some of the new highlights? Network Contract Wizard (NCW) Support for NAT hole punching Master Server has Matchmaking \"Cherry picked\" network variable updating State rewinding Network error logging system The Network Object Notes from Community Do not put NetworkManager into your scene, it will be spawned on its own Do not wrap your RPC calls in MainThreadManger.Run if you have the \"Use Main Thread Manager For RPCs\" enabled","title":"User Manual (Forge Networking Remastered)"},{"location":"#user-manual-forge-networking-remastered","text":"Welcome to Forge Networking Remastered, we would like to personally thank you for electing to become a part of our journey into Networking systems and Software as a whole. You are here because you have become a premium supporter of the Forge Networking project!","title":"User Manual (Forge Networking Remastered)"},{"location":"#here-for-the-code-api","text":"","title":"Here for the Code API?"},{"location":"#here-for-the-video-tutorials","text":"","title":"Here for the Video Tutorials?"},{"location":"#forge-networking-to-remastered-migration-guide","text":"First, we would like to thank you so much for supporting Forge Networking over the past two years and we are proud to bring you Forge Networking Remastered ! Forge Networking Remastered (FNR) is a re-imagining of networking for Forge. We took everything we learned, all the feedback we could get and we started from scratch on FNR. We kept some of the helper classes such as ObjectMapper and BMSByte as those were optimized classes just for generic network data transfer. Secondly, we started FNR with the thought of Web Sockets and WebGL in mind. Though (at the time of this writing) WebGL support is not officially complete, we are working very hard to solidify this platform (mainly in relation to Unity integration and limitations). Thirdly we wanted to completely remove any kind of reflection \"magic\" that was in the system. In place of reflection we opted for generated class files and code, this makes debugging and tracking execution much easier to maintain and test. Now for the reveal of the biggest change to Forge Networking, the Network Object. We have replaced the old singular, monolithic inheritance network model in place of an attachment network model. Now you can write your code as you wish without overly intrusive and complicated code/reflection and have a more solid extendable model. We have also included the new Network Contract Wizard (NCW) which allows you to easily blueprint and review your network contracts without having to dig through tons of code. We have completely re-imagined networking to be more of a service, attachment, addon, and extension rather than an overly complex integrated model. Of course you will find many things that you once knew such as Network Instantiation , Remote Procedure Calls RPC , MainThreadManager ( Threading in Unity ) however you will find that some of the older models (such as NetSync ) have been removed. I know, I know, NetSync is awesome and it works kinda like UNET's SyncVar ; however, we believe we have a much simpler, more controlled, less magical, and more powerful approach to serializing network variables. Since we have abstracted all the network code to be an attachment, you will find a new fancy network Object variable that is a part of the class you create. This object will house all of your network variables and allow you to set the sync time as well as access any variable from the network easily. This means you can choose when to use the network variable, choices are good, yes? Also, the networkObject is powerful, it automatically detects changes to your variable (as a whole) and serializes only that variable as opposed to the whole network class! So, what are the difference highlights? Instantiation is done through NetworkManager.Instance.Instantiate... Remote procedure calls are done through networkObject.SendRpc NetSync has become networkObject.[myVar] PrimarySocket has become NetworkManager.Instance.Networker (You can also get the networker from the networkObject ) WriteCustom has become Binary (Check out the VOIP module for how to use Binary) Networking and NetworkingManager have been replaced by NetworkManager So what are some of the new highlights? Network Contract Wizard (NCW) Support for NAT hole punching Master Server has Matchmaking \"Cherry picked\" network variable updating State rewinding Network error logging system The Network Object Notes from Community Do not put NetworkManager into your scene, it will be spawned on its own Do not wrap your RPC calls in MainThreadManger.Run if you have the \"Use Main Thread Manager For RPCs\" enabled","title":"Forge Networking to Remastered Migration Guide"},{"location":"adding-and-updating-docs/","text":"Adding and Updating Docs So you've discovered some new stuff in Forge Networking and you think that it would be important to add documentation around your discovery to share with the community. Great!! We love that and people like you is where real progress comes from :). So lets begin with the requirements to get started: Access to GitHub (You can get this by requesting it in Discord and providing your GitHub username) An updated checkout of your own fork of the Forge Networking Remastered repository A text editor to edit Markdown (.md) files in, we recommend Visual Studio Code And that is it! You are officially ready to start adding and updating the documentation via pull requests. Creating a New Page in the Docs We use MkDocs to generate our searchable documentation so it is extremely easy for you to create your page using Markdown. Below are the steps taken to create your own page: Open the ForgeNetworkingRemastered/docs/mkdocs/docs folder in the repo Create your file, if your page is called Azure Setup then you will create a file azure-setup.md in this folder Open and edit your .md file Save your file Open the ForgeNetworkingRemastered/docs/mkdocs/mkdocs.yml file Add your file to the appropriate section under pages: or create a new section if needed Commit your changes and create a pull request Once your pull request is accepted, we will run the MkDocs build and your documentation will be up on the website! Updating an Existing Page in the Docs If you find an error or feel that something is missing from the documentation you can do make a fix and submit it for review! Below are the steps in updating a page in the documentation: Open the ForgeNetworkingRemastered/docs/mkdocs/docs folder in the repo Find the page you want to update, if the page is called Azure Setup then you will find a file named azure-setup.md in this folder Open and edit your .md file Save your file Commit your changes and create a pull request","title":"Contributing"},{"location":"adding-and-updating-docs/#adding-and-updating-docs","text":"So you've discovered some new stuff in Forge Networking and you think that it would be important to add documentation around your discovery to share with the community. Great!! We love that and people like you is where real progress comes from :). So lets begin with the requirements to get started: Access to GitHub (You can get this by requesting it in Discord and providing your GitHub username) An updated checkout of your own fork of the Forge Networking Remastered repository A text editor to edit Markdown (.md) files in, we recommend Visual Studio Code And that is it! You are officially ready to start adding and updating the documentation via pull requests.","title":"Adding and Updating Docs"},{"location":"adding-and-updating-docs/#creating-a-new-page-in-the-docs","text":"We use MkDocs to generate our searchable documentation so it is extremely easy for you to create your page using Markdown. Below are the steps taken to create your own page: Open the ForgeNetworkingRemastered/docs/mkdocs/docs folder in the repo Create your file, if your page is called Azure Setup then you will create a file azure-setup.md in this folder Open and edit your .md file Save your file Open the ForgeNetworkingRemastered/docs/mkdocs/mkdocs.yml file Add your file to the appropriate section under pages: or create a new section if needed Commit your changes and create a pull request Once your pull request is accepted, we will run the MkDocs build and your documentation will be up on the website!","title":"Creating a New Page in the Docs"},{"location":"adding-and-updating-docs/#updating-an-existing-page-in-the-docs","text":"If you find an error or feel that something is missing from the documentation you can do make a fix and submit it for review! Below are the steps in updating a page in the documentation: Open the ForgeNetworkingRemastered/docs/mkdocs/docs folder in the repo Find the page you want to update, if the page is called Azure Setup then you will find a file named azure-setup.md in this folder Open and edit your .md file Save your file Commit your changes and create a pull request","title":"Updating an Existing Page in the Docs"},{"location":"authoritative-design/","text":"Authoritative Design Often you will hear the term authoritative server and in most cases, it is used to mean authoritative game logic . So, we would like to first go over the difference between the two as we often state that Forge Networking (including Remastered) is authoritative server by design. Authoritative Server: When all network traffic goes through the server before it is relayed to other clients. In other words, clients do not communicate with each other directly. Authoritative Game Logic: When all your game code is written in a way where the server is completely in control of the flow and owns all of the network objects. This is unique to your game and how your game plays, it can be complex based on your game and we would suggest exploring the idea of not having authoritative game logic unless your game requires it. Games that require it often are games that have long term tracking (such as Battlefield) or track data for users in a database (such as an MMO). Games that plan to have non-tracked multiplayer (such as Minecraft) would not opt into having full server authority due to the overhead of complexity. So when we say that Forge Networking (and Remastered) is an authoritative server we are talking about the former where all network traffic goes through the server first and then is relayed to all of the clients.","title":"Authoritative Design"},{"location":"authoritative-design/#authoritative-design","text":"Often you will hear the term authoritative server and in most cases, it is used to mean authoritative game logic . So, we would like to first go over the difference between the two as we often state that Forge Networking (including Remastered) is authoritative server by design. Authoritative Server: When all network traffic goes through the server before it is relayed to other clients. In other words, clients do not communicate with each other directly. Authoritative Game Logic: When all your game code is written in a way where the server is completely in control of the flow and owns all of the network objects. This is unique to your game and how your game plays, it can be complex based on your game and we would suggest exploring the idea of not having authoritative game logic unless your game requires it. Games that require it often are games that have long term tracking (such as Battlefield) or track data for users in a database (such as an MMO). Games that plan to have non-tracked multiplayer (such as Minecraft) would not opt into having full server authority due to the overhead of complexity. So when we say that Forge Networking (and Remastered) is an authoritative server we are talking about the former where all network traffic goes through the server first and then is relayed to all of the clients.","title":"Authoritative Design"},{"location":"ban-client-code/","text":"Ban Client Code Sometimes clients are just annoying and you want your hosts to be able to ban players from joining the server for a given amount of time (or what could be forever). To do this you need to use the reference to your server's NetWorker . // The amount of time in minutes that we want to ban the player int minutesToBan = 60; // 1 hour // Consider the player you want to disconnect is the targetPlayer object // We will want to get the players network id as we are going to do a generic ban // Note: If you have the network id from the RPC or any other messaging you can ban from there ulong playerId = targetPlayer.NetworkId; // Consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker) ((IServer)serverNetworker).BanPlayer(playerId, minutesToBan)","title":"Ban Client Code"},{"location":"ban-client-code/#ban-client-code","text":"Sometimes clients are just annoying and you want your hosts to be able to ban players from joining the server for a given amount of time (or what could be forever). To do this you need to use the reference to your server's NetWorker . // The amount of time in minutes that we want to ban the player int minutesToBan = 60; // 1 hour // Consider the player you want to disconnect is the targetPlayer object // We will want to get the players network id as we are going to do a generic ban // Note: If you have the network id from the RPC or any other messaging you can ban from there ulong playerId = targetPlayer.NetworkId; // Consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker) ((IServer)serverNetworker).BanPlayer(playerId, minutesToBan)","title":"Ban Client Code"},{"location":"connection-cycle-events/","text":"Connection Cycle Events Below are a quick explanation of the various events that happen during the connection and acceptance cycles on both the server and the client. Server Client Events The below are events that are local-aware, that is to say that they are called without any need for an active connection. bindSuccessful Called when the local machine allowed the binding of the port requested. bindFailure Called when the local machine rejected the binding of the port requested. disconnected Called when the local machine has completely disconnected from any communications in the Forge life cycle Server Events The following events are called on the server only based on the behavior of clients connecting or disconnecting. playerConnected Called when a player has successfully connected with the server. This player CAN be rejected by the server, so this event is mainly useful for evaluation of the player or preparing anything you need for the player. You should not be communicating with the player at all until they have been accepted. playerGuidAssigned This event is called once the server has gotten the unique guid for a player. This triggers just before the accepted message and is useful to prepare any network player lookups. playerAccepted Fired when the player has been officially accepted by the server and now is the time you are able to start sending your messages to this player. playerRejected Fired when a player has been rejected for any reason by the server. This event will be expanded later but currently is used for when a client has sent invalid connection headers. playerTimeout Called when a player has timed out on the server. This happens after they have been accepted and if the server hasn't received any message (ping or otherwise) from the specified client. The timeout time (in milliseconds) for a player can be found/set in the NetworkingPlayer::TimeoutMilliseconds property. playerDisconnected Called at any time that a player has disconnected on its own or by the server. Client Events The following events are called on the client only and deal with the various connection events that relate to this client and the server. serverAccepted Called whenever the server has accepted this client. At this point it is safe to start sending messages to the server and to know it is a live connection. connectAttemptFailed Called if the client cannot connect to the server. The client will make 10 connect attempts, waiting 3 seconds between attempts, then call this event if none of the connection attempts were successful.","title":"Events"},{"location":"connection-cycle-events/#connection-cycle-events","text":"Below are a quick explanation of the various events that happen during the connection and acceptance cycles on both the server and the client.","title":"Connection Cycle Events"},{"location":"connection-cycle-events/#server-client-events","text":"The below are events that are local-aware, that is to say that they are called without any need for an active connection.","title":"Server &amp; Client Events"},{"location":"connection-cycle-events/#bindsuccessful","text":"Called when the local machine allowed the binding of the port requested.","title":"bindSuccessful"},{"location":"connection-cycle-events/#bindfailure","text":"Called when the local machine rejected the binding of the port requested.","title":"bindFailure"},{"location":"connection-cycle-events/#disconnected","text":"Called when the local machine has completely disconnected from any communications in the Forge life cycle","title":"disconnected"},{"location":"connection-cycle-events/#server-events","text":"The following events are called on the server only based on the behavior of clients connecting or disconnecting.","title":"Server Events"},{"location":"connection-cycle-events/#playerconnected","text":"Called when a player has successfully connected with the server. This player CAN be rejected by the server, so this event is mainly useful for evaluation of the player or preparing anything you need for the player. You should not be communicating with the player at all until they have been accepted.","title":"playerConnected"},{"location":"connection-cycle-events/#playerguidassigned","text":"This event is called once the server has gotten the unique guid for a player. This triggers just before the accepted message and is useful to prepare any network player lookups.","title":"playerGuidAssigned"},{"location":"connection-cycle-events/#playeraccepted","text":"Fired when the player has been officially accepted by the server and now is the time you are able to start sending your messages to this player.","title":"playerAccepted"},{"location":"connection-cycle-events/#playerrejected","text":"Fired when a player has been rejected for any reason by the server. This event will be expanded later but currently is used for when a client has sent invalid connection headers.","title":"playerRejected"},{"location":"connection-cycle-events/#playertimeout","text":"Called when a player has timed out on the server. This happens after they have been accepted and if the server hasn't received any message (ping or otherwise) from the specified client. The timeout time (in milliseconds) for a player can be found/set in the NetworkingPlayer::TimeoutMilliseconds property.","title":"playerTimeout"},{"location":"connection-cycle-events/#playerdisconnected","text":"Called at any time that a player has disconnected on its own or by the server.","title":"playerDisconnected"},{"location":"connection-cycle-events/#client-events","text":"The following events are called on the client only and deal with the various connection events that relate to this client and the server.","title":"Client Events"},{"location":"connection-cycle-events/#serveraccepted","text":"Called whenever the server has accepted this client. At this point it is safe to start sending messages to the server and to know it is a live connection.","title":"serverAccepted"},{"location":"connection-cycle-events/#connectattemptfailed","text":"Called if the client cannot connect to the server. The client will make 10 connect attempts, waiting 3 seconds between attempts, then call this event if none of the connection attempts were successful.","title":"connectAttemptFailed"},{"location":"lan-discovery/","text":"UDP LAN Discovery LAN Discovery is a way for you to quickly find other game servers on the local area network. This is done by sending out a broadcast message on the local network that gets picked up by the game servers that are currently running. When they receive the lan discovery request they respond to the sender to let the sender know the IP addresses and port numbers that are available. There is only 1 method that needs to be called to use LAN Discovery in Forge Networking: NetWorker.RefreshLocalUdpListings(); The above is a static method that is called to trigger the request. Since this request is a threaded request, you can not expect to have any results immediately after the request has been made. So often you will want to listen for the various servers to respond. Below is an example of how to do this: NetWorker.localServerLocated += LocalServerLocated; NetWorker.RefreshLocalUdpListings(); // ... Some code and stuff private void LocalServerLocated(NetWorker.BroadcastEndpoints endpoint) { Debug.Log( Found endpoint: + endpoint.Address + : + endpoint.Port); } You can replace the above debug log with whatever code you would like. The endpoint contains the server that has responded (it's address and port number). With this information you are able to connect to the server. RefreshLocalUdpListings Notice that this is a refresh method, that means that you will need to call it each time you want to refresh the listings of servers on the network. This method can be called at an interval if you would like or you could have your players click a button to invoke it. Also notice that the RefreshLocalUdpListings takes in an argument (time in milliseconds) to wait for server responses. The default is 1000 (1 second). If a server doesn't respond in that amount of time it will not be counted. If you do not want to rely on the event callback alone you can also get the listings of servers from the NetWorker.LocalEndpoints list.","title":"LAN Discovery"},{"location":"lan-discovery/#udp-lan-discovery","text":"LAN Discovery is a way for you to quickly find other game servers on the local area network. This is done by sending out a broadcast message on the local network that gets picked up by the game servers that are currently running. When they receive the lan discovery request they respond to the sender to let the sender know the IP addresses and port numbers that are available. There is only 1 method that needs to be called to use LAN Discovery in Forge Networking: NetWorker.RefreshLocalUdpListings(); The above is a static method that is called to trigger the request. Since this request is a threaded request, you can not expect to have any results immediately after the request has been made. So often you will want to listen for the various servers to respond. Below is an example of how to do this: NetWorker.localServerLocated += LocalServerLocated; NetWorker.RefreshLocalUdpListings(); // ... Some code and stuff private void LocalServerLocated(NetWorker.BroadcastEndpoints endpoint) { Debug.Log( Found endpoint: + endpoint.Address + : + endpoint.Port); } You can replace the above debug log with whatever code you would like. The endpoint contains the server that has responded (it's address and port number). With this information you are able to connect to the server.","title":"UDP LAN Discovery"},{"location":"lan-discovery/#refreshlocaludplistings","text":"Notice that this is a refresh method, that means that you will need to call it each time you want to refresh the listings of servers on the network. This method can be called at an interval if you would like or you could have your players click a button to invoke it. Also notice that the RefreshLocalUdpListings takes in an argument (time in milliseconds) to wait for server responses. The default is 1000 (1 second). If a server doesn't respond in that amount of time it will not be counted. If you do not want to rely on the event callback alone you can also get the listings of servers from the NetWorker.LocalEndpoints list.","title":"RefreshLocalUdpListings"},{"location":"lobby/","text":"Lobby System The lobby system is a way for you to be able to manage your existing players on your particular server on a global level. With this system, you are able to do the following: Set Player Name (string) Set Avatar ID (int) Set Team ID (int) Send a message to everyone like the chat system (string) Kick player Start game button This system allows us to be able to control the list of players and functionality of those players at runtime. There is a basic dummy lobby master class that will be the default system chosen until overridden with either our custom Lobby Master (unity implementation) or your own Custom Lobby Master. Because of the way it is written for forge, this system does not need to be ran from Unity and can work perfectly fine on your linux builds (more on this later). Using the Existing Lobby System The existing lobby system is available out of the box to be used in your application. The one thing you want to check is if you are using the MultiplayerMenu and loading into your game then you'll be fine following skipping to step #2. First ensure that whatever network loading sequence you are going with, that the host will call the following code. LobbyService.Instance.Initialize(serversocket); Where the 'server socket' would be the socket that the host makes when hosting. You can see this being done in the example MultiplayerMenu.cs that is included with Forge Networking. Add the lobby system prefab (LobbySystem.prefab) to your game scene, or wherever you want to include the lobby system to your existing game. If you don't have an event system a standalone input module in your scene already, then you would need to make sure they are in there to interact with the lobby items as well. The lobby player item prefab is just a prefab that stores the users name, color, buttons and the like. You are free to modify this prefab to your liking as well as the lobby system itself. Congratulations you have officially added the lobby system to your game and can start using it! Change your name in your player top let, and start talking in the chat bottom left, change the UI to however you please as well as the prefab. PS- To get better results, make sure in the build settings Multiplayermenu - Lobby - Game Lobby Service API Calls The lobby service has built in api calls that are currently being used in the LobbyManager. For reason of explaining it further, these api calls can be called from anywhere in code as long as you are connected to a socket. This allows you to change the users name from anywhere other than the built in Lobby system. string newName = ; LobbyService.Instance.SetName(newName); uint playerID = 999; //Only the server will actually kick players LobbyService.Instance.KickPlayer(playerID); int avatarID = -1; LobbyService.Instance.SetAvatar(avatarID); int teamID = -1; LobbyService.Instance.SetTeamId(teamID); string chatMessage = ; LobbyService.Instance.SendPlayerMessage(chatMessage); Here is some examples of what the data structure of sending these api calls would look like. As stated before, these can be called anywhere in your code and your LobbyMaster/LobbyManager would handle the data received from other players. You can easily grab the list of players by doing the following: List IClientMockPlayer currentPlayers = LobbyService.Instance.MasterLobby.LobbyPlayers; This list will auto populate with the users that join and leave/disconnect. Lobby System Enhancements This section is for advanced users who want to expand the lobby system past what is already there for further functionality. Please take a look at the following classes: LobbyManager.cs LobbyPlayer.cs LobbyPlayerItem.cs Lobby Player Manager The lobby player manager is an example of how you would expand the lobby system itself. Right now it implements the functionality of ILobbyMaster and replaces the mock lobby system with this one during setup. You'll see that it replaces it in SetupComplete() with the following code. LobbyService.Instance.SetLobbyMaster(this); SetupComplete() also creates the player item for himself as well as for the already connected players. You'll notice that you can modify the data however you please and expand on it given the Interface API that is implemented because of the system. If you want to fully understand how the implementation is done, please take a further in-depth look at LobbyService.cs (which we will not cover in this documentation at the moment as it is a lot to go over). Lobby Player The purpose of the lobby player is to implement the IClientMockPlayer which will allow you to implement the basic data that we require for the lobby system to work and expand on it with your own custom data. Just note that if you want that data to be synced properly for any additional logic, you would have to implement the code to be in the lobby manager as well as the LobbyService, otherwise you can always sync the data from other networked objects to the lobby manager with RPC's as well. We will have to revisit this to help make expanding the player data, but just or now I recommend taking a look at the way the data is structured and used in the Lobby Manager in order to populate it as well as the Lobby Service. The Lobby Player is used extensively on our Lobby Manager to store the current state of a given player. Lobby Player Item The lobby player item prefab is used to populate itself with the data of a given player passed in. This is mostly just a ui helper and is not necessary for the player to exist as the lobby system itself will always have all the current players. For demonstration purposes we have included a simple prefab that is being populated in the provided lobby system included with Forge Networking. You are free to populate and change the ui however you please with this data passed in. We store a reference to the Lobby system itself, but you can easily do other ways of sending the button calls to your own custom lobby system by passing in the actions and the like. This way you would remove the need to have the lobby system being stored as a reference in every lobby player item. The reason we stuck with this format is to just showcase the ease of expanding this item with future features that we plan on adding. Start Game The start game button sends all the players to the Game scene. How this is setup in build settings. MultiplayerMenu - Lobby Scene - Game Here is the script of Start Game, if you want to use it in other applications. using System.Collections; using System.Collections.Generic; using UnityEngine; public class StartGame : MonoBehaviour { public void startGame (int Levelnum) { Application.LoadLevel(Levelnum); } } Create Your Own Lobby (Easier way) 1) Create a new scene. 2) Add the LobbySystem Prefab. 3) Change the UI, Change the buttons and edit/copy off of the LobbySystem Prefab. 4) make sure the scripts in the LobbySystem prefab go into the desired area in the scene as well as the Inspector (Button scripts go in the button scripts, etc). 5) add it to MultiplayerMenu - Lobby - Game Lobby Scene This Lobby can be used for your game or used as a reference for you to make your own Lobby. This is the Game-Scene. Lobby Overview This system allows us to be able to control the list of players and functionality of those players at runtime. There is a basic dummy lobby master class that will be the default system chosen until overridden with either our custom Lobby Master (unity implementation) or your own Custom Lobby Master. Because of the way it is written for forge, this system does not need to be ran from Unity and can work perfectly fine on your linux builds (more on this later). To Be Continued As the lobby system is a great system to add to your game, we are very open to suggestions that can add further features to this as well as give the users the ability to chime in over Discord. As we add more features expect this documentation to cover that and expand.","title":"Lobby System"},{"location":"lobby/#lobby-system","text":"The lobby system is a way for you to be able to manage your existing players on your particular server on a global level. With this system, you are able to do the following: Set Player Name (string) Set Avatar ID (int) Set Team ID (int) Send a message to everyone like the chat system (string) Kick player Start game button This system allows us to be able to control the list of players and functionality of those players at runtime. There is a basic dummy lobby master class that will be the default system chosen until overridden with either our custom Lobby Master (unity implementation) or your own Custom Lobby Master. Because of the way it is written for forge, this system does not need to be ran from Unity and can work perfectly fine on your linux builds (more on this later).","title":"Lobby System"},{"location":"lobby/#using-the-existing-lobby-system","text":"The existing lobby system is available out of the box to be used in your application. The one thing you want to check is if you are using the MultiplayerMenu and loading into your game then you'll be fine following skipping to step #2. First ensure that whatever network loading sequence you are going with, that the host will call the following code. LobbyService.Instance.Initialize(serversocket); Where the 'server socket' would be the socket that the host makes when hosting. You can see this being done in the example MultiplayerMenu.cs that is included with Forge Networking. Add the lobby system prefab (LobbySystem.prefab) to your game scene, or wherever you want to include the lobby system to your existing game. If you don't have an event system a standalone input module in your scene already, then you would need to make sure they are in there to interact with the lobby items as well. The lobby player item prefab is just a prefab that stores the users name, color, buttons and the like. You are free to modify this prefab to your liking as well as the lobby system itself. Congratulations you have officially added the lobby system to your game and can start using it! Change your name in your player top let, and start talking in the chat bottom left, change the UI to however you please as well as the prefab. PS- To get better results, make sure in the build settings Multiplayermenu - Lobby - Game","title":"Using the Existing Lobby System"},{"location":"lobby/#lobby-service-api-calls","text":"The lobby service has built in api calls that are currently being used in the LobbyManager. For reason of explaining it further, these api calls can be called from anywhere in code as long as you are connected to a socket. This allows you to change the users name from anywhere other than the built in Lobby system. string newName = ; LobbyService.Instance.SetName(newName); uint playerID = 999; //Only the server will actually kick players LobbyService.Instance.KickPlayer(playerID); int avatarID = -1; LobbyService.Instance.SetAvatar(avatarID); int teamID = -1; LobbyService.Instance.SetTeamId(teamID); string chatMessage = ; LobbyService.Instance.SendPlayerMessage(chatMessage); Here is some examples of what the data structure of sending these api calls would look like. As stated before, these can be called anywhere in your code and your LobbyMaster/LobbyManager would handle the data received from other players. You can easily grab the list of players by doing the following: List IClientMockPlayer currentPlayers = LobbyService.Instance.MasterLobby.LobbyPlayers; This list will auto populate with the users that join and leave/disconnect.","title":"Lobby Service API Calls"},{"location":"lobby/#lobby-system-enhancements","text":"This section is for advanced users who want to expand the lobby system past what is already there for further functionality. Please take a look at the following classes: LobbyManager.cs LobbyPlayer.cs LobbyPlayerItem.cs","title":"Lobby System Enhancements"},{"location":"lobby/#lobby-player-manager","text":"The lobby player manager is an example of how you would expand the lobby system itself. Right now it implements the functionality of ILobbyMaster and replaces the mock lobby system with this one during setup. You'll see that it replaces it in SetupComplete() with the following code. LobbyService.Instance.SetLobbyMaster(this); SetupComplete() also creates the player item for himself as well as for the already connected players. You'll notice that you can modify the data however you please and expand on it given the Interface API that is implemented because of the system. If you want to fully understand how the implementation is done, please take a further in-depth look at LobbyService.cs (which we will not cover in this documentation at the moment as it is a lot to go over).","title":"Lobby Player Manager"},{"location":"lobby/#lobby-player","text":"The purpose of the lobby player is to implement the IClientMockPlayer which will allow you to implement the basic data that we require for the lobby system to work and expand on it with your own custom data. Just note that if you want that data to be synced properly for any additional logic, you would have to implement the code to be in the lobby manager as well as the LobbyService, otherwise you can always sync the data from other networked objects to the lobby manager with RPC's as well. We will have to revisit this to help make expanding the player data, but just or now I recommend taking a look at the way the data is structured and used in the Lobby Manager in order to populate it as well as the Lobby Service. The Lobby Player is used extensively on our Lobby Manager to store the current state of a given player.","title":"Lobby Player"},{"location":"lobby/#lobby-player-item","text":"The lobby player item prefab is used to populate itself with the data of a given player passed in. This is mostly just a ui helper and is not necessary for the player to exist as the lobby system itself will always have all the current players. For demonstration purposes we have included a simple prefab that is being populated in the provided lobby system included with Forge Networking. You are free to populate and change the ui however you please with this data passed in. We store a reference to the Lobby system itself, but you can easily do other ways of sending the button calls to your own custom lobby system by passing in the actions and the like. This way you would remove the need to have the lobby system being stored as a reference in every lobby player item. The reason we stuck with this format is to just showcase the ease of expanding this item with future features that we plan on adding.","title":"Lobby Player Item"},{"location":"lobby/#start-game","text":"The start game button sends all the players to the Game scene. How this is setup in build settings. MultiplayerMenu - Lobby Scene - Game Here is the script of Start Game, if you want to use it in other applications. using System.Collections; using System.Collections.Generic; using UnityEngine; public class StartGame : MonoBehaviour { public void startGame (int Levelnum) { Application.LoadLevel(Levelnum); } }","title":"Start Game"},{"location":"lobby/#create-your-own-lobby-easier-way","text":"1) Create a new scene. 2) Add the LobbySystem Prefab. 3) Change the UI, Change the buttons and edit/copy off of the LobbySystem Prefab. 4) make sure the scripts in the LobbySystem prefab go into the desired area in the scene as well as the Inspector (Button scripts go in the button scripts, etc). 5) add it to MultiplayerMenu - Lobby - Game","title":"Create Your Own Lobby (Easier way)"},{"location":"lobby/#lobby-scene","text":"This Lobby can be used for your game or used as a reference for you to make your own Lobby. This is the Game-Scene.","title":"Lobby Scene"},{"location":"lobby/#lobby-overview","text":"This system allows us to be able to control the list of players and functionality of those players at runtime. There is a basic dummy lobby master class that will be the default system chosen until overridden with either our custom Lobby Master (unity implementation) or your own Custom Lobby Master. Because of the way it is written for forge, this system does not need to be ran from Unity and can work perfectly fine on your linux builds (more on this later).","title":"Lobby Overview"},{"location":"lobby/#to-be-continued","text":"As the lobby system is a great system to add to your game, we are very open to suggestions that can add further features to this as well as give the users the ability to chime in over Discord. As we add more features expect this documentation to cover that and expand.","title":"To Be Continued"},{"location":"nat-hole-punching/","text":"NAT Hole Punching Downloading NAT Hole Punch Server The NAT Hole Punch Server can either be built from source in the project repo, or downloaded from the nightly builds . Running NAT Hole Punch Server Nat hole punching is a way for users behind a firewall to be able to connect to each other without requiring them to open their firewall ports on their router. To do this, it requires a special server that is dedicated to registering hosts and keeping an open communication with that game host. When a client requests to join a host that is behind a NAT they will communicate with the NAT service host. This NAT service host will then act as a delegate to request that the game host begin communications with the requesting client. When you look at the Connect method of the ServerUDP and ClientUDP classes you will notice that there are 2 optional parameters related to nat traversal. One is the NAT host address and the other is the NAT server port. When you provide a NAT host address to the Connect method on a ServerUDP object, you will be telling the server where it needs to register itself and you will be opening communication with the NAT server for it to forward client connection requests. When you provide a NAT host address to the Connect method on a ClientUDP object, you will be telling the client to communicate with that specific NAT host to open communications with the desired server. Setting the correct NAT host in the Connect method of the ServerUDP and ClientUDP is all you will need to do in order to enable NAT hole punching in your application. Video Tutorial On How To Test","title":"NAT Hole Punching"},{"location":"nat-hole-punching/#nat-hole-punching","text":"","title":"NAT Hole Punching"},{"location":"nat-hole-punching/#downloading-nat-hole-punch-server","text":"The NAT Hole Punch Server can either be built from source in the project repo, or downloaded from the nightly builds .","title":"Downloading NAT Hole Punch Server"},{"location":"nat-hole-punching/#running-nat-hole-punch-server","text":"Nat hole punching is a way for users behind a firewall to be able to connect to each other without requiring them to open their firewall ports on their router. To do this, it requires a special server that is dedicated to registering hosts and keeping an open communication with that game host. When a client requests to join a host that is behind a NAT they will communicate with the NAT service host. This NAT service host will then act as a delegate to request that the game host begin communications with the requesting client. When you look at the Connect method of the ServerUDP and ClientUDP classes you will notice that there are 2 optional parameters related to nat traversal. One is the NAT host address and the other is the NAT server port. When you provide a NAT host address to the Connect method on a ServerUDP object, you will be telling the server where it needs to register itself and you will be opening communication with the NAT server for it to forward client connection requests. When you provide a NAT host address to the Connect method on a ClientUDP object, you will be telling the client to communicate with that specific NAT host to open communications with the desired server. Setting the correct NAT host in the Connect method of the ServerUDP and ClientUDP is all you will need to do in order to enable NAT hole punching in your application.","title":"Running NAT Hole Punch Server"},{"location":"nat-hole-punching/#video-tutorial-on-how-to-test","text":"","title":"Video Tutorial On How To Test"},{"location":"network-logging/","text":"Network Logging Forge Networking has it's own logging system built in for the purposes of debugging and tracing any errors that may happen during network communication. When an exception is thrown on the networking layer, the logging system will pick that up and process the log. There are currently 2 main forms of logging that is built into the system, the in-game logging and the file system logging. We do not recommend using the in-game logging for any production environment, however we do suggest that you enable file logging for production environments. The Forge Networking logger will only log network exceptions so it will not have any impact on performance, except if there are many exceptions being thrown (which shouldn't happen unless there is a critical process error in the game). This log does a little more than just log network exceptions however; it also logs exceptions that are thrown by your code during the network transport time. Things such as an invalid parameter to an RPC or an invalid cast being performed by your code. Because of this, we recommend always having this log available when testing your code in order to reduce support tickets on our end and in order to keep you as productive as possible towards your awesome product! How To Enable Logging Navigate to Bearded Man Studios IncScripts- Logging- ResourcesBMSLogger Having the BMSLogger selected, you can then check 'Log To File' This will then allow you to log all exceptions and common networking debug logs into the logging folder (including logs that you write). How to Enable Visible Logging Note: This will allow you to see the logs in the build itself on any device. Navigate to Bearded Man Studios IncScripts- Logging- ResourcesBMSLogger Having the BMSLogger selected, you can then check 'Logger Visible' The final location of this log file will be dependent on whether it is in the editor or a build. Editor location: Root Unity DirectoryAsset Logsbmslog.txt Windows Build Location: ExecutableDirectoryExecutableName_DataLogsbmslog.txt Using the Logger yourself for development purposes Example Logging BeardedManStudios.Forge.Logging.BMSLog.Log( ANYTHING YOU WANT TO LOGHERE! ); BeardedManStudios.Forge.Logging.BMSLog.LogFormat( FOLLOWING A FORMAT[{0}] , ANYTHING YOU WANT TO LOG HERE! ); BeardedManStudios.Forge.Logging.BMSLog.LogWarning( ANYTHING YOU WANT TO LOGHERE! ); BeardedManStudios.Forge.Logging.BMSLog.LogWarningFormat( FOLLOWING A FORMAT[{0}] , ANYTHING YOU WANT TO LOG HERE! ); BeardedManStudios.Forge.Logging.BMSLog.LogException([System.Exception]); BeardedManStudios.Forge.Logging.BMSLog.LogException( ANYTHING YOU WANT TOLOG HERE! ); BeardedManStudios.Forge.Logging.BMSLog.LogExceptionFormat( FOLLOWING AFORMAT [{0}] , ANYTHING YOU WANT TO LOG HERE! ); Above is code examples of how to call the logger to use it for logging purposes. Note: All exceptions will automatically be logged, so put them in places that should never be called frequently, useful for testing on builds and figuring out what went wrong on the network.","title":"Debugging"},{"location":"network-logging/#network-logging","text":"Forge Networking has it's own logging system built in for the purposes of debugging and tracing any errors that may happen during network communication. When an exception is thrown on the networking layer, the logging system will pick that up and process the log. There are currently 2 main forms of logging that is built into the system, the in-game logging and the file system logging. We do not recommend using the in-game logging for any production environment, however we do suggest that you enable file logging for production environments. The Forge Networking logger will only log network exceptions so it will not have any impact on performance, except if there are many exceptions being thrown (which shouldn't happen unless there is a critical process error in the game). This log does a little more than just log network exceptions however; it also logs exceptions that are thrown by your code during the network transport time. Things such as an invalid parameter to an RPC or an invalid cast being performed by your code. Because of this, we recommend always having this log available when testing your code in order to reduce support tickets on our end and in order to keep you as productive as possible towards your awesome product! How To Enable Logging Navigate to Bearded Man Studios IncScripts- Logging- ResourcesBMSLogger Having the BMSLogger selected, you can then check 'Log To File' This will then allow you to log all exceptions and common networking debug logs into the logging folder (including logs that you write). How to Enable Visible Logging Note: This will allow you to see the logs in the build itself on any device. Navigate to Bearded Man Studios IncScripts- Logging- ResourcesBMSLogger Having the BMSLogger selected, you can then check 'Logger Visible' The final location of this log file will be dependent on whether it is in the editor or a build. Editor location: Root Unity DirectoryAsset Logsbmslog.txt Windows Build Location: ExecutableDirectoryExecutableName_DataLogsbmslog.txt Using the Logger yourself for development purposes","title":"Network Logging"},{"location":"network-logging/#example-logging","text":"BeardedManStudios.Forge.Logging.BMSLog.Log( ANYTHING YOU WANT TO LOGHERE! ); BeardedManStudios.Forge.Logging.BMSLog.LogFormat( FOLLOWING A FORMAT[{0}] , ANYTHING YOU WANT TO LOG HERE! ); BeardedManStudios.Forge.Logging.BMSLog.LogWarning( ANYTHING YOU WANT TO LOGHERE! ); BeardedManStudios.Forge.Logging.BMSLog.LogWarningFormat( FOLLOWING A FORMAT[{0}] , ANYTHING YOU WANT TO LOG HERE! ); BeardedManStudios.Forge.Logging.BMSLog.LogException([System.Exception]); BeardedManStudios.Forge.Logging.BMSLog.LogException( ANYTHING YOU WANT TOLOG HERE! ); BeardedManStudios.Forge.Logging.BMSLog.LogExceptionFormat( FOLLOWING AFORMAT [{0}] , ANYTHING YOU WANT TO LOG HERE! ); Above is code examples of how to call the logger to use it for logging purposes. Note: All exceptions will automatically be logged, so put them in places that should never be called frequently, useful for testing on builds and figuring out what went wrong on the network.","title":"Example Logging"},{"location":"offline-mode/","text":"How to Make \"Offline\" Mode Something you may be curious about is how you can make your game both single player and multi-player. Your main problem is probably going to be trying to figure out how you can separate all your RPC calls and your offline direct calls. The thing that may surprise you is if we were to say that there is no need for the distinction between \"Online\" and \"Offline\" code. The Solo Server So if you think about it, single player could very well be a server that has the following attributes: 1. Does not register with a master server 2. Does not register with a nat traversal server 3. Does not accept any connections (max players is 0) 4. Blocks any other connection attempts Well this makes sense so far, if a server doesn't accept any clients then technically it is nothing more than an offline game. However, what about the RPC calls and the various other networked things like the networkObject? Well, the answer is simple, Forge Networking was built to where the server isolation is offline play. If there are no connections to the server, it will call all RPCs directly without any network layer involved for sending (it doesn't send to itself, just runs the method locally). Below is an example of a server put into an offline like state: // Zero connections allowed to this server NetWorker server = new UdpServer(0); server.Connect(); // Block all connections to skip the validation phase ((IServer)server).StopAcceptingConnections(); Notes When you specify receivers that do not include the server, such as Receivers.Others then the server will not call the method, even with no other connections.","title":"Offline Mode"},{"location":"offline-mode/#how-to-make-offline-mode","text":"Something you may be curious about is how you can make your game both single player and multi-player. Your main problem is probably going to be trying to figure out how you can separate all your RPC calls and your offline direct calls. The thing that may surprise you is if we were to say that there is no need for the distinction between \"Online\" and \"Offline\" code.","title":"How to Make \"Offline\" Mode"},{"location":"offline-mode/#the-solo-server","text":"So if you think about it, single player could very well be a server that has the following attributes: 1. Does not register with a master server 2. Does not register with a nat traversal server 3. Does not accept any connections (max players is 0) 4. Blocks any other connection attempts Well this makes sense so far, if a server doesn't accept any clients then technically it is nothing more than an offline game. However, what about the RPC calls and the various other networked things like the networkObject? Well, the answer is simple, Forge Networking was built to where the server isolation is offline play. If there are no connections to the server, it will call all RPCs directly without any network layer involved for sending (it doesn't send to itself, just runs the method locally). Below is an example of a server put into an offline like state: // Zero connections allowed to this server NetWorker server = new UdpServer(0); server.Connect(); // Block all connections to skip the validation phase ((IServer)server).StopAcceptingConnections();","title":"The Solo Server"},{"location":"offline-mode/#notes","text":"When you specify receivers that do not include the server, such as Receivers.Others then the server will not call the method, even with no other connections.","title":"Notes"},{"location":"rewinding/","text":"Rewinding Rewinding is a method in which you can go back in \"time\" and look at what the value of a variable was at/around a specific timestep. The Rewind data structure is a pretty simple structure that allows you to do rewinding however you would like. Since you are able to get the Timestep at any point in your code through the use of NetworkManager.Instance.NetWorker.Time.Timestep , you can easily store anything into the structure that you need. Below is an example showing you how to get started with rewinding in a practical way. Create a C# file in your project Name the file RewindTest.cs Open the file and paste the code following these steps Create a new scene Place a cube in the scene Attach the RewindTeste.cs script to the cube Attach a Rigidbody component to the cube Save the scene as RewindTest Open the Multiplayer Menu sample scene Open the build settings Click the Player Settings... button Make sure Run in Background is turned on Add the Multiplayer Menu Scene as scene (index 0) to the build settings Add the RewindTest scene as the second scene (index 1) to the build settings Press play Host a game Wait a second or two Press the spacebar Check the GET message and what time it was at Check the SET message with the closest time to that seen in the get message and you will notice they are a match using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Unity; using System.Collections; using UnityEngine; public class RewindTest : MonoBehaviour { private Rewind Vector3 rewind; private void Start() { rewind = new Rewind Vector3 (5000); StartCoroutine(Store()); } private void Update() { if (Input.GetKeyDown(KeyCode.Space)) { var timestep = NetworkManager.Instance.Networker.Time.Timestep - 1000; Debug.Log( GET: + timestep + | + rewind.Get(timestep)); UnityEditor.EditorApplication.isPaused = true; } } private IEnumerator Store() { for (;;) { var timestep = NetworkManager.Instance.Networker.Time.Timestep; rewind.Register(transform.position, timestep); Debug.Log( SET: + timestep + | + transform.position); yield return new WaitForSeconds(0.5f); } } } Deeper Dive You will notice in the above example we do rewind = new Rewind Vector3 (5000); . The 5000 in this case is the number of milliseconds to track data. Anything older than 5 seconds from now will be removed for memory constraint purposes. You can put whatever time frame you want here, 5000 may be a bit much (because 5000ms is 5 seconds which is a very long time). The Vector3 is the type of data that we are storing into this rewinding structure. Next you will notice the rewind.Register(transform.position, timestep); call. This will save the value of transform.position to the rewind history at the provided ulong timestep . This adds to the pool of stored data for this specific variable for you to pull from. Note It is not good practice to Register different Vector3 addresses, so if we are using rewind for transform.position we should only pass transform.position into this variable's Register method. Lastly we come to the most important action we can do rewind.Get(timestep) . There are many different overloads for getting the values near and around a timestep however the simplest method to call is Get . So let's say you Register a value A at timestep 3 and a value B at timestep 20 . If you were to call Get(10) then you will get value A returned, however if you called Get(19) you would get the value B . This is because the value closest to the sent timestamp would be returned. Other Get Methods List T Get(ulong timestep, out T lower, out T upper) - If we were following the above example and we passed Get(10, out lower, out upper) into this method, then lower would equal 3 , upper would equal 20 and the returned value will be 3 . This method is useful for if you want to calculate a median or where the value might possibly be between the two values. List T GetRange(ulong timestep, int count) - This method will act exactly like the first Get method we learned about in the Deeper Dive section above; however, it also will return n values before the given timestep. So if we passed in 3 for the count then we would get a list of values back where the first element is the target value for that timestep and every element after that is the value stored at the last timestep registered. T GetRange(ulong timestepMin, ulong timestepMax) - This method allows you to get all values between two timesteps (including the min and the max).","title":"Rewinding"},{"location":"rewinding/#rewinding","text":"Rewinding is a method in which you can go back in \"time\" and look at what the value of a variable was at/around a specific timestep. The Rewind data structure is a pretty simple structure that allows you to do rewinding however you would like. Since you are able to get the Timestep at any point in your code through the use of NetworkManager.Instance.NetWorker.Time.Timestep , you can easily store anything into the structure that you need. Below is an example showing you how to get started with rewinding in a practical way. Create a C# file in your project Name the file RewindTest.cs Open the file and paste the code following these steps Create a new scene Place a cube in the scene Attach the RewindTeste.cs script to the cube Attach a Rigidbody component to the cube Save the scene as RewindTest Open the Multiplayer Menu sample scene Open the build settings Click the Player Settings... button Make sure Run in Background is turned on Add the Multiplayer Menu Scene as scene (index 0) to the build settings Add the RewindTest scene as the second scene (index 1) to the build settings Press play Host a game Wait a second or two Press the spacebar Check the GET message and what time it was at Check the SET message with the closest time to that seen in the get message and you will notice they are a match using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Unity; using System.Collections; using UnityEngine; public class RewindTest : MonoBehaviour { private Rewind Vector3 rewind; private void Start() { rewind = new Rewind Vector3 (5000); StartCoroutine(Store()); } private void Update() { if (Input.GetKeyDown(KeyCode.Space)) { var timestep = NetworkManager.Instance.Networker.Time.Timestep - 1000; Debug.Log( GET: + timestep + | + rewind.Get(timestep)); UnityEditor.EditorApplication.isPaused = true; } } private IEnumerator Store() { for (;;) { var timestep = NetworkManager.Instance.Networker.Time.Timestep; rewind.Register(transform.position, timestep); Debug.Log( SET: + timestep + | + transform.position); yield return new WaitForSeconds(0.5f); } } }","title":"Rewinding"},{"location":"rewinding/#deeper-dive","text":"You will notice in the above example we do rewind = new Rewind Vector3 (5000); . The 5000 in this case is the number of milliseconds to track data. Anything older than 5 seconds from now will be removed for memory constraint purposes. You can put whatever time frame you want here, 5000 may be a bit much (because 5000ms is 5 seconds which is a very long time). The Vector3 is the type of data that we are storing into this rewinding structure. Next you will notice the rewind.Register(transform.position, timestep); call. This will save the value of transform.position to the rewind history at the provided ulong timestep . This adds to the pool of stored data for this specific variable for you to pull from. Note It is not good practice to Register different Vector3 addresses, so if we are using rewind for transform.position we should only pass transform.position into this variable's Register method. Lastly we come to the most important action we can do rewind.Get(timestep) . There are many different overloads for getting the values near and around a timestep however the simplest method to call is Get . So let's say you Register a value A at timestep 3 and a value B at timestep 20 . If you were to call Get(10) then you will get value A returned, however if you called Get(19) you would get the value B . This is because the value closest to the sent timestamp would be returned.","title":"Deeper Dive"},{"location":"rewinding/#other-get-methods","text":"List T Get(ulong timestep, out T lower, out T upper) - If we were following the above example and we passed Get(10, out lower, out upper) into this method, then lower would equal 3 , upper would equal 20 and the returned value will be 3 . This method is useful for if you want to calculate a median or where the value might possibly be between the two values. List T GetRange(ulong timestep, int count) - This method will act exactly like the first Get method we learned about in the Deeper Dive section above; however, it also will return n values before the given timestep. So if we passed in 3 for the count then we would get a list of values back where the first element is the target value for that timestep and every element after that is the value stored at the last timestep registered. T GetRange(ulong timestepMin, ulong timestepMax) - This method allows you to get all values between two timesteps (including the min and the max).","title":"Other Get Methods"},{"location":"server-disconnect-client-code/","text":"Server Disconnect Client Code Sometimes it is necessary to manually disconnect a player from the server (on the server). First you will need to find out which NetworkingPlayer you are wishing to kick on the server. Once you have a reference to that player, you are going to want to call the disconnect on them. To do this you need to use the reference to your server's NetWorker . // We are going to force the disconnect of the client bool forcefully = true; // Consider the player you want to disconnect is the targetPlayer object // Also consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker) ((IServer)serverNetworker).Disconnect(targetPlayer, forcefully); That is it, you are ready to start kicking all of the players! :D","title":"Server Disconnect Client Code"},{"location":"server-disconnect-client-code/#server-disconnect-client-code","text":"Sometimes it is necessary to manually disconnect a player from the server (on the server). First you will need to find out which NetworkingPlayer you are wishing to kick on the server. Once you have a reference to that player, you are going to want to call the disconnect on them. To do this you need to use the reference to your server's NetWorker . // We are going to force the disconnect of the client bool forcefully = true; // Consider the player you want to disconnect is the targetPlayer object // Also consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker) ((IServer)serverNetworker).Disconnect(targetPlayer, forcefully); That is it, you are ready to start kicking all of the players! :D","title":"Server Disconnect Client Code"},{"location":"working-with-multiple-sockets/","text":"Working With Multiple Sockets Working in Forge Networking you may have found that it is extremely easy to setup a server and then setup a client to communicate with each other. Just in case you have forgotten, lets take a trip down memory lane: ushort myPort = 15937; UDPServer myServer = new UDPServer(32); // Only allowing 32 connections to this server myServer.Connect(port: myPort); Looking above you might be thinking \"wow, why use any other networking solution\" and that is a very good question. Alright, so sure, it is easy to make a server... so how would you go about making 3 servers that run at the same time huh!? The answer is easy, let us do this through example below: UDPServer server1 = new UDPServer(32); // Only allowing 32 connections to this UDP server server1.Connect(); ushort myPort = 15959; TCPServer server2 = new TCPServer(364); // Only allowing 64 connections to this TCP server server2.Connect(myPort); UDPServer server3 = new UDPServer(1024); // Only allowing 1024 connections to this UDP server server3.Connect(myPort + 1); And just like that we have 3 servers server1 , server2 , and server3 . These three servers are 3 different servers and manage their own players, network objects, RPCs, and pretty much everything else. Be warned, with great power comes great responsibility! You must always be aware of what networker is being communicated with and also know that the NetworkManager can only manage 1 NetWorker for the game. That means that the Instantiate methods and everything else that works with the network on the NetworkManager is for that \"main\" NetWorker. This means you need to do the work of disconnecting these servers when the application exits as well, otherwise the application will hang when the user tries to exit. You are also responsible for managing the references to these NetWorkers as well. Matching Players on Separate NetWorkers What kind of guys would we be if we didn't tell you about the awesome NetWorker::FindMatchingPlayer method. Each NetWorker has a method FindMatchingPlayer that can be called to find players that match across the different NetWorkers. Remember that just because a player is id 22 on NetWorkerA doesn't mean it will be 22 on NetWorkerB.","title":"Working With Multiple Sockets"},{"location":"working-with-multiple-sockets/#working-with-multiple-sockets","text":"Working in Forge Networking you may have found that it is extremely easy to setup a server and then setup a client to communicate with each other. Just in case you have forgotten, lets take a trip down memory lane: ushort myPort = 15937; UDPServer myServer = new UDPServer(32); // Only allowing 32 connections to this server myServer.Connect(port: myPort); Looking above you might be thinking \"wow, why use any other networking solution\" and that is a very good question. Alright, so sure, it is easy to make a server... so how would you go about making 3 servers that run at the same time huh!? The answer is easy, let us do this through example below: UDPServer server1 = new UDPServer(32); // Only allowing 32 connections to this UDP server server1.Connect(); ushort myPort = 15959; TCPServer server2 = new TCPServer(364); // Only allowing 64 connections to this TCP server server2.Connect(myPort); UDPServer server3 = new UDPServer(1024); // Only allowing 1024 connections to this UDP server server3.Connect(myPort + 1); And just like that we have 3 servers server1 , server2 , and server3 . These three servers are 3 different servers and manage their own players, network objects, RPCs, and pretty much everything else. Be warned, with great power comes great responsibility! You must always be aware of what networker is being communicated with and also know that the NetworkManager can only manage 1 NetWorker for the game. That means that the Instantiate methods and everything else that works with the network on the NetworkManager is for that \"main\" NetWorker. This means you need to do the work of disconnecting these servers when the application exits as well, otherwise the application will hang when the user tries to exit. You are also responsible for managing the references to these NetWorkers as well.","title":"Working With Multiple Sockets"},{"location":"working-with-multiple-sockets/#matching-players-on-separate-networkers","text":"What kind of guys would we be if we didn't tell you about the awesome NetWorker::FindMatchingPlayer method. Each NetWorker has a method FindMatchingPlayer that can be called to find players that match across the different NetWorkers. Remember that just because a player is id 22 on NetWorkerA doesn't mean it will be 22 on NetWorkerB.","title":"Matching Players on Separate NetWorkers"},{"location":"BasicNetworkSamples/ban-client-code/","text":"Ban Client Code Sometimes clients are just annoying and you want your hosts to be able to ban players from joining the server for a given amount of time (or what could be forever). To do this you need to use the reference to your server's NetWorker . // The amount of time in minutes that we want to ban the player int minutesToBan = 60; // 1 hour // Consider the player you want to disconnect is the targetPlayer object // We will want to get the players network id as we are going to do a generic ban // Note: If you have the network id from the RPC or any other messaging you can ban from there ulong playerId = targetPlayer.NetworkId; // Consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker) ((IServer)serverNetworker).BanPlayer(playerId, minutesToBan)","title":"Ban Client Code"},{"location":"BasicNetworkSamples/ban-client-code/#ban-client-code","text":"Sometimes clients are just annoying and you want your hosts to be able to ban players from joining the server for a given amount of time (or what could be forever). To do this you need to use the reference to your server's NetWorker . // The amount of time in minutes that we want to ban the player int minutesToBan = 60; // 1 hour // Consider the player you want to disconnect is the targetPlayer object // We will want to get the players network id as we are going to do a generic ban // Note: If you have the network id from the RPC or any other messaging you can ban from there ulong playerId = targetPlayer.NetworkId; // Consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker) ((IServer)serverNetworker).BanPlayer(playerId, minutesToBan)","title":"Ban Client Code"},{"location":"BasicNetworkSamples/client-connecting-code/","text":"Client Connecting Code Before you can take full advantage of setting up a client, you will probably want to setup server hosting code so that the client has something to actually connect to. Below is a sample of how to start a UDP Client and a TCP Client. UDP Client string hostAddress = 127.0.0.1 ; ushort port = 15937; UDPClient client = new UDPClient(); client.Connect(hostAddress, port); TCP Client TCPClient client = new TCPClient(); client.Connect(hostAddress, port); Assigning to Network Manager Hard to believe? Yes that is all the code you need to start up a client, now there is one more important piece of business we must complete. Since this client is most likely going to be the main communication NetWorker with the server and the game, you are probably going to want to set it up as the default NetWorker for the NetworkManager to use. You can do this with the following: // The client object is the same object from the above code samples NetworkManager.Instance.Initialize(client); By doing this, the passed in client will be the NetWorker that is used for all communication managed by the NetworkManager . This includes spawning objects, RPC calls on those objects, scene transitions and so forth.","title":"Client Connecting Code"},{"location":"BasicNetworkSamples/client-connecting-code/#client-connecting-code","text":"Before you can take full advantage of setting up a client, you will probably want to setup server hosting code so that the client has something to actually connect to. Below is a sample of how to start a UDP Client and a TCP Client.","title":"Client Connecting Code"},{"location":"BasicNetworkSamples/client-connecting-code/#udp-client","text":"string hostAddress = 127.0.0.1 ; ushort port = 15937; UDPClient client = new UDPClient(); client.Connect(hostAddress, port);","title":"UDP Client"},{"location":"BasicNetworkSamples/client-connecting-code/#tcp-client","text":"TCPClient client = new TCPClient(); client.Connect(hostAddress, port);","title":"TCP Client"},{"location":"BasicNetworkSamples/client-connecting-code/#assigning-to-network-manager","text":"Hard to believe? Yes that is all the code you need to start up a client, now there is one more important piece of business we must complete. Since this client is most likely going to be the main communication NetWorker with the server and the game, you are probably going to want to set it up as the default NetWorker for the NetworkManager to use. You can do this with the following: // The client object is the same object from the above code samples NetworkManager.Instance.Initialize(client); By doing this, the passed in client will be the NetWorker that is used for all communication managed by the NetworkManager . This includes spawning objects, RPC calls on those objects, scene transitions and so forth.","title":"Assigning to Network Manager"},{"location":"BasicNetworkSamples/send-binary-frame/","text":"Send Binary Frame The Binary frame (BeardedManStudios.Forge.Networking.Frame.Binary) is a child of the FrameStream object which is how all messages are sent in Forge (even our internal code). To use this you need to serialize your data to a byte[] or pack it into a BMSByte object (wrapper around byte[] for caching). First you need to create your data byte[] data = { /* Your data */ }; Next you need to create the frame, since you want to send it to a specific player you will need to make the receivers be Target const MY_GROUP_ID = MessageGroupIds .START_OF_GENERIC_IDS + 1; // Just a random message group id that is not being used anywhere else // \u2026 ulong timestep = NetworkManager.Instance.Networker.Time.Timestep; bool isTcpClient = NetworkManager.Instance.Networker is TCPClient; bool isTcp = NetworkManager.Instance.Networker is BaseTCP; Binary bin = new Binary(timestep, isTcpClient, data, Receivers.Target, MY_GROUP_ID, isTcp); Now that you have your binary frame named \"bin\", you can send it across the network. This is assuming that you are sending this frame from the server if (networker is UDPServer) { bool isReliable = true; ((UDPServer)networker).Send(targetNetworkingPlayer, bin, isReliable); } else ((TCPServer)networker).Send(targetNetworkingPlayer, bin); To read this message you need to listen to the NetWorker::binaryMessageReceived event on the client. You can filter by the group id you've specified NetworkManager.Instance.Networker.binaryMessageReceived += ReadBinary; // ... private void ReadBinary(NetworkingPlayer player, Binary frame, NetWorker sender) { if (frame.GroupId != MY_GROUP_ID) return; // TODO: Your code here }","title":"Send Binary Frame"},{"location":"BasicNetworkSamples/send-binary-frame/#send-binary-frame","text":"The Binary frame (BeardedManStudios.Forge.Networking.Frame.Binary) is a child of the FrameStream object which is how all messages are sent in Forge (even our internal code). To use this you need to serialize your data to a byte[] or pack it into a BMSByte object (wrapper around byte[] for caching). First you need to create your data byte[] data = { /* Your data */ }; Next you need to create the frame, since you want to send it to a specific player you will need to make the receivers be Target const MY_GROUP_ID = MessageGroupIds .START_OF_GENERIC_IDS + 1; // Just a random message group id that is not being used anywhere else // \u2026 ulong timestep = NetworkManager.Instance.Networker.Time.Timestep; bool isTcpClient = NetworkManager.Instance.Networker is TCPClient; bool isTcp = NetworkManager.Instance.Networker is BaseTCP; Binary bin = new Binary(timestep, isTcpClient, data, Receivers.Target, MY_GROUP_ID, isTcp); Now that you have your binary frame named \"bin\", you can send it across the network. This is assuming that you are sending this frame from the server if (networker is UDPServer) { bool isReliable = true; ((UDPServer)networker).Send(targetNetworkingPlayer, bin, isReliable); } else ((TCPServer)networker).Send(targetNetworkingPlayer, bin); To read this message you need to listen to the NetWorker::binaryMessageReceived event on the client. You can filter by the group id you've specified NetworkManager.Instance.Networker.binaryMessageReceived += ReadBinary; // ... private void ReadBinary(NetworkingPlayer player, Binary frame, NetWorker sender) { if (frame.GroupId != MY_GROUP_ID) return; // TODO: Your code here }","title":"Send Binary Frame"},{"location":"BasicNetworkSamples/send-file/","text":"Send File Forge Networking works with all kinds of data, but that doesn't exclude sending files across the network. At the end of the day, files are just an array of bytes ( byte[] ) and by now, you probably know you can send that stuff over the network with Forge Networking. So let's get started with a simple desktop- desktop file transfer shall we! The Setup To get started we are going to need to setup our environment so that we can quickly and easily test our code. So let's open up a project with Forge Networking imported into it to get started. 1) Download the deal-with-it.jpg image (cat image below) 2) Open project with Forge Networking imported 3) Create a folder named FileTransfer 4) Copy the deal-with-it.jpg image into the FileTransfer folder 5) Create a new scene and save it into the FileTransfer folder named FileTransferTest 6) Create a C# script in the FileTransfer folder named SendThatFile 7) Open that script in your favorite editor 8) Put the following code into the script Note that this code is not optimized but made simple for quick understanding using BeardedManStudios; using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Frame; using BeardedManStudios.Forge.Networking.Unity; using System.IO; using UnityEngine; public class SendThatFile : MonoBehaviour { public string filePath; private bool sentFile; private void Start() { NetworkManager.Instance.Networker.binaryMessageReceived += ReceiveFile; } private void ReceiveFile(NetworkingPlayer player, Binary frame) { // We are looking to read a very specific message if (frame.GroupId != MessageGroupIds.START_OF_GENERIC_IDS + 1) return; Debug.Log( Reading file! ); // Read the string from the beginning of the payload string fileName = frame.StreamData.GetBasicType string (); Debug.Log( File name is + fileName); if (File.Exists(fileName)) { Debug.LogError( The file + fileName + already exists! ); return; } // Write the rest of the payload as the contents of the file and // use the file name that was extracted as the file's name File.WriteAllBytes(fileName, frame.StreamData.CompressBytes()); } private void Update() { if (Input.GetKeyDown(KeyCode.Space) !sentFile) { sentFile = true; // Throw an error if this is not the server var networker = NetworkManager.Instance.Networker; if (!networker.IsServer) { Debug.LogError( Only the server can send files in this example! ); return; } // Throw an error if the file does not exist if (!File.Exists(filePath)) { Debug.LogError( The file + filePath + could not be found ); return; } // Prepare a byte array for sending BMSByte allData = new BMSByte(); // Add the file name to the start of the payload ObjectMapper.Instance.MapBytes(allData, Path.GetFileName(filePath)); // Add the data to the payload allData.Append(File.ReadAllBytes(filePath)); // Send the file to all connected clients Binary frame = new Binary( networker.Time.Timestep, // The current timestep for this frame false, // We are server, no mask needed allData, // The file that is being sent Receivers.Others, // Send to all clients MessageGroupIds.START_OF_GENERIC_IDS + 1, // Some random fake number networker is TCPServer); if (networker is UDPServer) ((UDPServer)networker).Send(frame, true); else ((TCPServer)networker).SendAll(frame); } } } Preparing to run 1) Open the Unity build menu 2) Add the MultiplayerMenu scene as the first scene 3) Add the FileTransferTest as the second scene 4) Open the Player Settings... 5) Turn on run in background 6) Open the FileTransferTest scene 7) Select the camera or any object in the scene 8) Add the SendThatFile script to the object 9) Update the File Path field on the script to have the full path to the deal-with-it.jpg image inside of the FileTransfer folder 10) Save the scene 11) Build and Run 12) Open 2 instances of the game 13) Set one to be the server then connect with the other 14) Press the spacebar on the server 15) Go into the build folder for the player and then go up a directory, you will notice a deal-with-it.jpg has been created","title":"Send File"},{"location":"BasicNetworkSamples/send-file/#send-file","text":"Forge Networking works with all kinds of data, but that doesn't exclude sending files across the network. At the end of the day, files are just an array of bytes ( byte[] ) and by now, you probably know you can send that stuff over the network with Forge Networking. So let's get started with a simple desktop- desktop file transfer shall we!","title":"Send File"},{"location":"BasicNetworkSamples/send-file/#the-setup","text":"To get started we are going to need to setup our environment so that we can quickly and easily test our code. So let's open up a project with Forge Networking imported into it to get started. 1) Download the deal-with-it.jpg image (cat image below) 2) Open project with Forge Networking imported 3) Create a folder named FileTransfer 4) Copy the deal-with-it.jpg image into the FileTransfer folder 5) Create a new scene and save it into the FileTransfer folder named FileTransferTest 6) Create a C# script in the FileTransfer folder named SendThatFile 7) Open that script in your favorite editor 8) Put the following code into the script Note that this code is not optimized but made simple for quick understanding using BeardedManStudios; using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Frame; using BeardedManStudios.Forge.Networking.Unity; using System.IO; using UnityEngine; public class SendThatFile : MonoBehaviour { public string filePath; private bool sentFile; private void Start() { NetworkManager.Instance.Networker.binaryMessageReceived += ReceiveFile; } private void ReceiveFile(NetworkingPlayer player, Binary frame) { // We are looking to read a very specific message if (frame.GroupId != MessageGroupIds.START_OF_GENERIC_IDS + 1) return; Debug.Log( Reading file! ); // Read the string from the beginning of the payload string fileName = frame.StreamData.GetBasicType string (); Debug.Log( File name is + fileName); if (File.Exists(fileName)) { Debug.LogError( The file + fileName + already exists! ); return; } // Write the rest of the payload as the contents of the file and // use the file name that was extracted as the file's name File.WriteAllBytes(fileName, frame.StreamData.CompressBytes()); } private void Update() { if (Input.GetKeyDown(KeyCode.Space) !sentFile) { sentFile = true; // Throw an error if this is not the server var networker = NetworkManager.Instance.Networker; if (!networker.IsServer) { Debug.LogError( Only the server can send files in this example! ); return; } // Throw an error if the file does not exist if (!File.Exists(filePath)) { Debug.LogError( The file + filePath + could not be found ); return; } // Prepare a byte array for sending BMSByte allData = new BMSByte(); // Add the file name to the start of the payload ObjectMapper.Instance.MapBytes(allData, Path.GetFileName(filePath)); // Add the data to the payload allData.Append(File.ReadAllBytes(filePath)); // Send the file to all connected clients Binary frame = new Binary( networker.Time.Timestep, // The current timestep for this frame false, // We are server, no mask needed allData, // The file that is being sent Receivers.Others, // Send to all clients MessageGroupIds.START_OF_GENERIC_IDS + 1, // Some random fake number networker is TCPServer); if (networker is UDPServer) ((UDPServer)networker).Send(frame, true); else ((TCPServer)networker).SendAll(frame); } } }","title":"The Setup"},{"location":"BasicNetworkSamples/send-file/#preparing-to-run","text":"1) Open the Unity build menu 2) Add the MultiplayerMenu scene as the first scene 3) Add the FileTransferTest as the second scene 4) Open the Player Settings... 5) Turn on run in background 6) Open the FileTransferTest scene 7) Select the camera or any object in the scene 8) Add the SendThatFile script to the object 9) Update the File Path field on the script to have the full path to the deal-with-it.jpg image inside of the FileTransfer folder 10) Save the scene 11) Build and Run 12) Open 2 instances of the game 13) Set one to be the server then connect with the other 14) Press the spacebar on the server 15) Go into the build folder for the player and then go up a directory, you will notice a deal-with-it.jpg has been created","title":"Preparing to run"},{"location":"BasicNetworkSamples/server-disconnect-client-code/","text":"Server Disconnect Client Code Sometimes it is necessary to manually disconnect a player from the server (on the server). First you will need to find out which NetworkingPlayer you are wishing to kick on the server. Once you have a reference to that player, you are going to want to call the disconnect on them. To do this you need to use the reference to your server's NetWorker . // We are going to force the disconnect of the client bool forcefully = true; // Consider the player you want to disconnect is the targetPlayer object // Also consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker) ((IServer)serverNetworker).Disconnect(targetPlayer, forcefully); That is it, you are ready to start kicking all of the players! :D","title":"Server Disconnect Client Code"},{"location":"BasicNetworkSamples/server-disconnect-client-code/#server-disconnect-client-code","text":"Sometimes it is necessary to manually disconnect a player from the server (on the server). First you will need to find out which NetworkingPlayer you are wishing to kick on the server. Once you have a reference to that player, you are going to want to call the disconnect on them. To do this you need to use the reference to your server's NetWorker . // We are going to force the disconnect of the client bool forcefully = true; // Consider the player you want to disconnect is the targetPlayer object // Also consider that serverNetworker is the server's networker (this can be NetworkManager.Instance.Networker) ((IServer)serverNetworker).Disconnect(targetPlayer, forcefully); That is it, you are ready to start kicking all of the players! :D","title":"Server Disconnect Client Code"},{"location":"BasicNetworkSamples/server-hosting-code/","text":"Server Hosting Code So you may have looked at the MultiplayerMenu.cs file and noticed there is a lot of amazing useful code samples there, but sometimes all that code can be a bit overwhelming and you just want to know How do I start a server? . Below is a sample of how to start a UDP Server and a TCP Server. UDP Server int maxAllowedClients = 32; UDPServer server = new UDPServer(maxAllowedClients); server.Connect(); TCP Server int maxAllowedClients = 32; TCPServer server = new TCPServer(maxAllowedClients); server.Connect(); It is worth noting that both UDPServer and TCPServer implement the IServer interface and derive from the NetWorker . So there are many casting and generic options to choose from. There are arguments that go into the Connect methods of these types, but they are for the Master Server and Nat Server . Assigning to Network Manager Hard to believe? , Yes that is all the code you need to start up a server, now there is one more important piece of business we must complete. Since this server is most likely going to be the main communication NetWorker with the clients and the game, you are probably going to want to set it up as the default NetWorker for the NetworkManager to use. You can do this with the following: // The server object is the same object from the above code samples NetworkManager.Instance.Initialize(server); By doing this, the passed in server will be the NetWorker that is used for all communication managed by the NetworkManager . This includes spawning objects, RPC calls on those objects, scene transitions and so forth.","title":"Server Hosting Code"},{"location":"BasicNetworkSamples/server-hosting-code/#server-hosting-code","text":"So you may have looked at the MultiplayerMenu.cs file and noticed there is a lot of amazing useful code samples there, but sometimes all that code can be a bit overwhelming and you just want to know How do I start a server? . Below is a sample of how to start a UDP Server and a TCP Server.","title":"Server Hosting Code"},{"location":"BasicNetworkSamples/server-hosting-code/#udp-server","text":"int maxAllowedClients = 32; UDPServer server = new UDPServer(maxAllowedClients); server.Connect();","title":"UDP Server"},{"location":"BasicNetworkSamples/server-hosting-code/#tcp-server","text":"int maxAllowedClients = 32; TCPServer server = new TCPServer(maxAllowedClients); server.Connect(); It is worth noting that both UDPServer and TCPServer implement the IServer interface and derive from the NetWorker . So there are many casting and generic options to choose from. There are arguments that go into the Connect methods of these types, but they are for the Master Server and Nat Server .","title":"TCP Server"},{"location":"BasicNetworkSamples/server-hosting-code/#assigning-to-network-manager","text":"Hard to believe? , Yes that is all the code you need to start up a server, now there is one more important piece of business we must complete. Since this server is most likely going to be the main communication NetWorker with the clients and the game, you are probably going to want to set it up as the default NetWorker for the NetworkManager to use. You can do this with the following: // The server object is the same object from the above code samples NetworkManager.Instance.Initialize(server); By doing this, the passed in server will be the NetWorker that is used for all communication managed by the NetworkManager . This includes spawning objects, RPC calls on those objects, scene transitions and so forth.","title":"Assigning to Network Manager"},{"location":"GettingStarted/basic-instantiation-example/","text":"Basic Instantiation Example Note: We assume that you have gone through the Basic Moving Cube Example and the Basic RPC Example before going through this example. This example is not a continuation of other examples and should be treated as if it were done in a new project. In this example we are going to create a simple cube to act as the player object. The \"player\" should be able to move their individual cube using the horizontal and vertical axis input. For this we will create a scene without any cubes in it, then when a connection is made or the server is created, we will spawn a cube \"player\" for the newly connected client or created server. Planning Network Code So one of the first things we want to think about is our Network Contract . This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will create a player cube for itself, it will also see all of the other connected cubes and their movements: Player creates a cube for itself when connected Synchronize the position and rotation of the player cube to all the clients and server The transformations should be smooth so we need to interpolate them Network Contract Wizard Now that we know that we need to sync the position and rotation of a cube, we can design our network contract for that object. We will first open the Network Contract Wizard which is a UI provided by the Bearded Man Studios team to make it easy to design your network contracts in an easy way. To open this menu, go into Unity and select \"Window- Forge Networking- Network Contract Wizard\". Once you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the Network Contract Wizard as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the Name fields, the Fields field, and the Remote Procedure Calls field. The Name field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated. The Fields section shows all of the various fields that our network should be aware of. In this case we are going to want to make a position and rotation field which are Vector3 and Quaternion respectively. Note, you can name these fields whatever you like, these are just friendly variable names for you (and your team) to know what they are for when used The Remote Procedure Calls field is where you will design any Remote Procedure Call (RPC) function signatures. We are not going to go over this field in this tutorial as we do not need it for the goal we are attempting to accomplish. Lets begin by naming our Network Object: Lets set the name for our Network object to \" PlayerCube \" (without quotes) Click the Add Field button Name the new field position Set the type to Vector3 Click the Interpolate button Set the interpolate time (the text field that pops up after clicking the Interpolate button) as 0.15 Click the Add Field button Name the new field rotation Set the type to Quaternion Click the Interpolate button Set the interpolate time (the text field that pops up after clicking the Interpolate button) as 0.15 12. Click the Save Compile button Extending Generated Classes When we use the Network Contract Wizard (NCW) we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class in particular that we want to extend from, this class name will be \" PlayerCubeBehavior \". The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Lets now create a C# file in Unity and write our basic game logic, we will name this file \" PlayerCube \". Open the newly created C# file Add using BeardedManStudios.Forge.Networking.Generated; to the using statements Derive the class from PlayerCubeBehavior Write the rest of the logic for the cube as seen below PlayerCube using UnityEngine; using BeardedManStudios.Forge.Networking.Generated; public class PlayerCube : PlayerCubeBehavior { /// summary /// The speed that this cube should move by when there are axis inputs /// /summary public float speed = 5.0f; private void Update() { // If this is not owned by the current network client then it needs to // assign it to the position and rotation specified if (!networkObject.IsOwner) { // Assign the position of this cube to the position sent on the network transform.position = networkObject.position; // Assign the rotation of this cube to the rotation sent on the network transform.rotation = networkObject.rotation; // Stop the function here and don't run any more code in this function return; } // Get the movement based on the axis input values Vector3 translation = new Vector3(Input.GetAxis( Horizontal ), 0, Input.GetAxis( Vertical )).normalized; // Scale the speed to normalize for processors translation *= speed * Time.deltaTime; // Move the object by the given translation transform.position += translation; // Just a random rotation on all axis transform.Rotate(new Vector3(speed, speed, speed) * 0.25f); // Since we are the owner, tell the network the updated position networkObject.position = transform.position; // Since we are the owner, tell the network the updated rotation networkObject.rotation = transform.rotation; // Note: Forge Networking takes care of only sending the delta, so there // is no need for you to do that manually } } Setting up prefab Since we are going to instantiate this object when a player connects, we will need a prefab that identifies this object. To quickly create a prefab that has a cube we will use the standard Unity process. Right click on the Hierarchy Hover our mouse over 3D Object Click on Cube in the following context menu Now that we have created a cube we need to set it up with the class PlayerCube class we just created Select the cube Click on the Add Component button in the Inspector Type in PlayerCube into the search Click the PlayerCube script to attach it Now that we have setup our player object it is time for us to create the prefab that will be instantiated when clients connect. Select the cube in the Hierarchy Drag the cube into the Project area to create the prefab Rename this prefab PlayerCube , this step is not required, just helps the example stay cohesive With this we are prepared to setup our NetworkManager to support the new instantiation of the object. Attaching the PlayerCube prefab for instantiation If you search the project directory you will find a prefab named NetworkManager . This is a default prefab we have created for you to get started. You can make your own prefab or alter this one if you wish to extend behavior. Now we will go through the process of attaching our created PlayerCube prefab to this NetworkManager Select the NetworkManager prefab in the project Locate the field named Player Cube Network Object You will notice that this is an array, set the Size to 1 Click the radial (circle) on the right of the Element 0 input field Locate and select the PlayerCube prefab Setup Instantiation Scene Now that we have setup our NetworkManager we are ready to make our instantiate code. To do this we will create a script that will instantiate our player Open up a new scene Create a new C# script named GameLogic Open the newly created C# file Add using BeardedManStudios.Forge.Networking.Unity; to the using statements Write the rest of the logic for instantiating the cube (seen below) Attach the newly created script to the Main Camera object in the scene (this is just to have the script in the scene, no other particular reason) Save the scene as GameScene Add the MultiplayerMenu scene as the first scene Add your GameScene scene as the second scene GameLogic using UnityEngine; using BeardedManStudios.Forge.Networking.Unity; public class GameLogic : MonoBehaviour { private void Start() { NetworkManager.Instance.InstantiatePlayerCube(); } } Test Now that we have setup our scene and everything else, it is time to test the game. Open the Build Settings Click on Player Settings... Open the Resolution and Presentation section Turn on Run In Background* Go back to Build Settings Click on Build And Run Once the game is open, return to the Unity Editor Open the MultiplayerMenu scene Click the play button Click the Host (127.0.0.1:15937) button on the bottom of the game view Go back to the built game Make sure the host ip address is set to 127.0.0.1 Make sure the host port is set to 15937 Click the Connect button Select the server game instance (Unity Editor) Now if you move around the cube in the editor, you will see the movements replicated to the client(s). If you move the cube around in the client(s) you will see the cube moving on the server. Our code has the cube constantly rotating so you will see them doing that as well. Troubleshooting Getting a null reference exception? The most common user errors with this part of the documentation are: Forgot to turn on Run in Background* Tried pressing the play button in the scene and not loading the MultiplayerMenu scene first Not setting up the MultiplayerMenu scene as index 0 and the demo scene as index 1","title":"Basic Instantiation Example"},{"location":"GettingStarted/basic-instantiation-example/#basic-instantiation-example","text":"Note: We assume that you have gone through the Basic Moving Cube Example and the Basic RPC Example before going through this example. This example is not a continuation of other examples and should be treated as if it were done in a new project. In this example we are going to create a simple cube to act as the player object. The \"player\" should be able to move their individual cube using the horizontal and vertical axis input. For this we will create a scene without any cubes in it, then when a connection is made or the server is created, we will spawn a cube \"player\" for the newly connected client or created server.","title":"Basic Instantiation Example"},{"location":"GettingStarted/basic-instantiation-example/#planning-network-code","text":"So one of the first things we want to think about is our Network Contract . This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will create a player cube for itself, it will also see all of the other connected cubes and their movements: Player creates a cube for itself when connected Synchronize the position and rotation of the player cube to all the clients and server The transformations should be smooth so we need to interpolate them","title":"Planning Network Code"},{"location":"GettingStarted/basic-instantiation-example/#network-contract-wizard","text":"Now that we know that we need to sync the position and rotation of a cube, we can design our network contract for that object. We will first open the Network Contract Wizard which is a UI provided by the Bearded Man Studios team to make it easy to design your network contracts in an easy way. To open this menu, go into Unity and select \"Window- Forge Networking- Network Contract Wizard\". Once you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the Network Contract Wizard as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the Name fields, the Fields field, and the Remote Procedure Calls field. The Name field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated. The Fields section shows all of the various fields that our network should be aware of. In this case we are going to want to make a position and rotation field which are Vector3 and Quaternion respectively. Note, you can name these fields whatever you like, these are just friendly variable names for you (and your team) to know what they are for when used The Remote Procedure Calls field is where you will design any Remote Procedure Call (RPC) function signatures. We are not going to go over this field in this tutorial as we do not need it for the goal we are attempting to accomplish. Lets begin by naming our Network Object: Lets set the name for our Network object to \" PlayerCube \" (without quotes) Click the Add Field button Name the new field position Set the type to Vector3 Click the Interpolate button Set the interpolate time (the text field that pops up after clicking the Interpolate button) as 0.15 Click the Add Field button Name the new field rotation Set the type to Quaternion Click the Interpolate button Set the interpolate time (the text field that pops up after clicking the Interpolate button) as 0.15 12. Click the Save Compile button","title":"Network Contract Wizard"},{"location":"GettingStarted/basic-instantiation-example/#extending-generated-classes","text":"When we use the Network Contract Wizard (NCW) we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class in particular that we want to extend from, this class name will be \" PlayerCubeBehavior \". The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Lets now create a C# file in Unity and write our basic game logic, we will name this file \" PlayerCube \". Open the newly created C# file Add using BeardedManStudios.Forge.Networking.Generated; to the using statements Derive the class from PlayerCubeBehavior Write the rest of the logic for the cube as seen below","title":"Extending Generated Classes"},{"location":"GettingStarted/basic-instantiation-example/#playercube","text":"using UnityEngine; using BeardedManStudios.Forge.Networking.Generated; public class PlayerCube : PlayerCubeBehavior { /// summary /// The speed that this cube should move by when there are axis inputs /// /summary public float speed = 5.0f; private void Update() { // If this is not owned by the current network client then it needs to // assign it to the position and rotation specified if (!networkObject.IsOwner) { // Assign the position of this cube to the position sent on the network transform.position = networkObject.position; // Assign the rotation of this cube to the rotation sent on the network transform.rotation = networkObject.rotation; // Stop the function here and don't run any more code in this function return; } // Get the movement based on the axis input values Vector3 translation = new Vector3(Input.GetAxis( Horizontal ), 0, Input.GetAxis( Vertical )).normalized; // Scale the speed to normalize for processors translation *= speed * Time.deltaTime; // Move the object by the given translation transform.position += translation; // Just a random rotation on all axis transform.Rotate(new Vector3(speed, speed, speed) * 0.25f); // Since we are the owner, tell the network the updated position networkObject.position = transform.position; // Since we are the owner, tell the network the updated rotation networkObject.rotation = transform.rotation; // Note: Forge Networking takes care of only sending the delta, so there // is no need for you to do that manually } }","title":"PlayerCube"},{"location":"GettingStarted/basic-instantiation-example/#setting-up-prefab","text":"Since we are going to instantiate this object when a player connects, we will need a prefab that identifies this object. To quickly create a prefab that has a cube we will use the standard Unity process. Right click on the Hierarchy Hover our mouse over 3D Object Click on Cube in the following context menu Now that we have created a cube we need to set it up with the class PlayerCube class we just created Select the cube Click on the Add Component button in the Inspector Type in PlayerCube into the search Click the PlayerCube script to attach it Now that we have setup our player object it is time for us to create the prefab that will be instantiated when clients connect. Select the cube in the Hierarchy Drag the cube into the Project area to create the prefab Rename this prefab PlayerCube , this step is not required, just helps the example stay cohesive With this we are prepared to setup our NetworkManager to support the new instantiation of the object.","title":"Setting up prefab"},{"location":"GettingStarted/basic-instantiation-example/#attaching-the-playercube-prefab-for-instantiation","text":"If you search the project directory you will find a prefab named NetworkManager . This is a default prefab we have created for you to get started. You can make your own prefab or alter this one if you wish to extend behavior. Now we will go through the process of attaching our created PlayerCube prefab to this NetworkManager Select the NetworkManager prefab in the project Locate the field named Player Cube Network Object You will notice that this is an array, set the Size to 1 Click the radial (circle) on the right of the Element 0 input field Locate and select the PlayerCube prefab","title":"Attaching the PlayerCube prefab for instantiation"},{"location":"GettingStarted/basic-instantiation-example/#setup-instantiation-scene","text":"Now that we have setup our NetworkManager we are ready to make our instantiate code. To do this we will create a script that will instantiate our player Open up a new scene Create a new C# script named GameLogic Open the newly created C# file Add using BeardedManStudios.Forge.Networking.Unity; to the using statements Write the rest of the logic for instantiating the cube (seen below) Attach the newly created script to the Main Camera object in the scene (this is just to have the script in the scene, no other particular reason) Save the scene as GameScene Add the MultiplayerMenu scene as the first scene Add your GameScene scene as the second scene","title":"Setup Instantiation &amp; Scene"},{"location":"GettingStarted/basic-instantiation-example/#gamelogic","text":"using UnityEngine; using BeardedManStudios.Forge.Networking.Unity; public class GameLogic : MonoBehaviour { private void Start() { NetworkManager.Instance.InstantiatePlayerCube(); } }","title":"GameLogic"},{"location":"GettingStarted/basic-instantiation-example/#test","text":"Now that we have setup our scene and everything else, it is time to test the game. Open the Build Settings Click on Player Settings... Open the Resolution and Presentation section Turn on Run In Background* Go back to Build Settings Click on Build And Run Once the game is open, return to the Unity Editor Open the MultiplayerMenu scene Click the play button Click the Host (127.0.0.1:15937) button on the bottom of the game view Go back to the built game Make sure the host ip address is set to 127.0.0.1 Make sure the host port is set to 15937 Click the Connect button Select the server game instance (Unity Editor) Now if you move around the cube in the editor, you will see the movements replicated to the client(s). If you move the cube around in the client(s) you will see the cube moving on the server. Our code has the cube constantly rotating so you will see them doing that as well.","title":"Test"},{"location":"GettingStarted/basic-instantiation-example/#troubleshooting","text":"Getting a null reference exception? The most common user errors with this part of the documentation are: Forgot to turn on Run in Background* Tried pressing the play button in the scene and not loading the MultiplayerMenu scene first Not setting up the MultiplayerMenu scene as index 0 and the demo scene as index 1","title":"Troubleshooting"},{"location":"GettingStarted/basic-moving-cube-example/","text":"Basic Moving Cube Example This example is not a continuation of other examples and should be treated as if it were done in a new project. In this example, we are going to make a simple game where we have a cube in the scene that is owned by the server and all the clients can see it being moved by the server. Planning Network Code So, one of the first things we want to think about is our Network Contract . This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will see a cube, then the cube will move around in sync with the server, who is the person actually moving the cube. To accomplish this, we need to: Have a cube already in the scene Synchronize the position and rotation of the cube to all the clients from the server The transformations should be smooth so we need to interpolate them Network Contract Wizard Now that we know that we need to sync the position and rotation of a cube, we can design our network contract for that object. We will first open the Network Contract Wizard which is a UI provided by the Bearded Man Studios team to make it easy to design your network contracts in an easy way. To open this menu, go into Unity and select \"Window- Forge Networking- Network Contract Wizard\". Once you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the Network Contract Wizard as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the Name fields, the Fields field, and the Remote Procedure Calls field. The Name field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated. The Fields section shows all of the various fields that our network should be aware of. In this case, we are going to want to make a position and rotation field which are Vector3 and Quaternion respectively. Note, you can name these fields whatever you like, these are just friendly variable names for you (and your team) to know what they are for when used The Remote Procedure Calls field is where you will design any Remote Procedure Call (RPC) function signatures. We are not going to go over this field in this tutorial as we do not need it for the goal we are attempting to accomplish. Let's begin by naming our Network Object: Let's set the name for our Network object to BasicCube Click the Add Field button Name the new field position Set the type to Vector3 Click the Interpolate button Set the interpolate time (the text field that pops up after clicking the Interpolate button) as 0.15 Click the Add Field button Name the new field rotation Set the type to Quaternion Click the Interpolate button Set the interpolate time (the text field that pops up after clicking the Interpolate button) as 0.15 Click the Save Compile button Extending Generated Classes When we use the Network Contract Wizard (NCW) we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class in particular that we want to extend from, this class name will be BasicCubeBehavior . The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Let's now create a C# file in Unity and write our basic game logic, we will name this file BasicCube . Open the newly created C# file Add using BeardedManStudios.Forge.Networking.Generated; to the using statements Derive the class from BasicCubeBehavior Write the rest of the logic for the cube as seen below BasicCube using UnityEngine; using BeardedManStudios.Forge.Networking.Generated; public class BasicCube : BasicCubeBehavior { /// summary /// The speed that the cube will move by when the user presses a /// Horizontal or Vertical mapped key /// /summary public float speed = 5.0f; private void Update() { // If we are not the owner of this network object then we should // move this cube to the position/rotation dictated by the owner if (!networkObject.IsOwner) { transform.position = networkObject.position; transform.rotation = networkObject.rotation; return; } // Let the owner move the cube around with the arrow keys transform.position += new Vector3(Input.GetAxis( Horizontal ), 0, Input.GetAxis( Vertical )).normalized * speed * Time.deltaTime; // If we are the owner of the object we should send the new position // and rotation across the network for receivers to move to in the above code networkObject.position = transform.position; networkObject.rotation = transform.rotation; // Note: Forge Networking takes care of only sending the delta, so there // is no need for you to do that manually } } As you can see from the code snippet above, you can determine if the current player is the owner of the object using the networkObject.IsOwner boolean comparison. This will allow you to make code specifically based on the owner of the object. In this case, since the cube is going to be in the scene at start, it's owner is the server . In the snippet above the client (non owner) will update the transform position and rotation of the cube (the object this script is going to be attached to) to the position and rotation received from the server. Since we turned on interpolation, all of the smoothing is done \"behind the scenes\". Now the server in this case will just assign the position and rotation variables of the networkObject. These are the two fields we created in the NCW by the way. All generated network objects from the NCW will have a networkObject member variable that you can access from the deriving child. Whenever you assign a field of this object it is replicated across the network if the assigning user is the owner of the object. Scene Setup Now that we have done all the network programming required for our end goal, it is time to setup our scene. Create a new scene in unity Create a cube for your floor Set the position of this cube on the x , y , and z to 0 , 0 , 0 respectively Set this cube's scale on the x , y , and z to 25 , 0.1 , 25 respectively Create another cube which will act as the active moving cube Set the position of this cube on the x , y , and z to 0 , 3 , 0 respectively Attach a 3D Rigidbody Component to the cube Attach our BasicCube script to this cube Save the scene as BasicCube Open up the build properties for Unity Add the MultiplayerMenu scene as the first scene Add your BasicCube scene as the second scene Test Now that we have setup our scene and everything else, it is time to test the game. Open the Build Settings Click on Player Settings... Open the Resolution and Presentation section Turn on Run In Background* Go back to Build Settings Click on Build And Run Once the game is open, return to the Unity Editor Open the MultiplayerMenu scene Click the play button Click the Host (127.0.0.1:15937) button on the bottom of the game view Go back to the built game Make sure the host ip address is set to 127.0.0.1 Make sure the host port is set to 15937 Click the Connect button Select the server game instance (Unity Editor) Now if you move around the cube in the editor, you will see the movements replicated to the clients. Troubleshooting Getting a null reference exception? The most common user errors with this part of the documentation are: Forgot to turn on Run in Background* Tried pressing the play button in the scene and not loading the Multiplayer Menu scene first Not setting up the multiplayer menu scene as index 0 and the demo scene as index 1","title":"Basic Moving Cube Example"},{"location":"GettingStarted/basic-moving-cube-example/#basic-moving-cube-example","text":"This example is not a continuation of other examples and should be treated as if it were done in a new project. In this example, we are going to make a simple game where we have a cube in the scene that is owned by the server and all the clients can see it being moved by the server.","title":"Basic Moving Cube Example"},{"location":"GettingStarted/basic-moving-cube-example/#planning-network-code","text":"So, one of the first things we want to think about is our Network Contract . This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will see a cube, then the cube will move around in sync with the server, who is the person actually moving the cube. To accomplish this, we need to: Have a cube already in the scene Synchronize the position and rotation of the cube to all the clients from the server The transformations should be smooth so we need to interpolate them","title":"Planning Network Code"},{"location":"GettingStarted/basic-moving-cube-example/#network-contract-wizard","text":"Now that we know that we need to sync the position and rotation of a cube, we can design our network contract for that object. We will first open the Network Contract Wizard which is a UI provided by the Bearded Man Studios team to make it easy to design your network contracts in an easy way. To open this menu, go into Unity and select \"Window- Forge Networking- Network Contract Wizard\". Once you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the Network Contract Wizard as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the Name fields, the Fields field, and the Remote Procedure Calls field. The Name field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated. The Fields section shows all of the various fields that our network should be aware of. In this case, we are going to want to make a position and rotation field which are Vector3 and Quaternion respectively. Note, you can name these fields whatever you like, these are just friendly variable names for you (and your team) to know what they are for when used The Remote Procedure Calls field is where you will design any Remote Procedure Call (RPC) function signatures. We are not going to go over this field in this tutorial as we do not need it for the goal we are attempting to accomplish. Let's begin by naming our Network Object: Let's set the name for our Network object to BasicCube Click the Add Field button Name the new field position Set the type to Vector3 Click the Interpolate button Set the interpolate time (the text field that pops up after clicking the Interpolate button) as 0.15 Click the Add Field button Name the new field rotation Set the type to Quaternion Click the Interpolate button Set the interpolate time (the text field that pops up after clicking the Interpolate button) as 0.15 Click the Save Compile button","title":"Network Contract Wizard"},{"location":"GettingStarted/basic-moving-cube-example/#extending-generated-classes","text":"When we use the Network Contract Wizard (NCW) we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class in particular that we want to extend from, this class name will be BasicCubeBehavior . The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Let's now create a C# file in Unity and write our basic game logic, we will name this file BasicCube . Open the newly created C# file Add using BeardedManStudios.Forge.Networking.Generated; to the using statements Derive the class from BasicCubeBehavior Write the rest of the logic for the cube as seen below","title":"Extending Generated Classes"},{"location":"GettingStarted/basic-moving-cube-example/#basiccube","text":"using UnityEngine; using BeardedManStudios.Forge.Networking.Generated; public class BasicCube : BasicCubeBehavior { /// summary /// The speed that the cube will move by when the user presses a /// Horizontal or Vertical mapped key /// /summary public float speed = 5.0f; private void Update() { // If we are not the owner of this network object then we should // move this cube to the position/rotation dictated by the owner if (!networkObject.IsOwner) { transform.position = networkObject.position; transform.rotation = networkObject.rotation; return; } // Let the owner move the cube around with the arrow keys transform.position += new Vector3(Input.GetAxis( Horizontal ), 0, Input.GetAxis( Vertical )).normalized * speed * Time.deltaTime; // If we are the owner of the object we should send the new position // and rotation across the network for receivers to move to in the above code networkObject.position = transform.position; networkObject.rotation = transform.rotation; // Note: Forge Networking takes care of only sending the delta, so there // is no need for you to do that manually } } As you can see from the code snippet above, you can determine if the current player is the owner of the object using the networkObject.IsOwner boolean comparison. This will allow you to make code specifically based on the owner of the object. In this case, since the cube is going to be in the scene at start, it's owner is the server . In the snippet above the client (non owner) will update the transform position and rotation of the cube (the object this script is going to be attached to) to the position and rotation received from the server. Since we turned on interpolation, all of the smoothing is done \"behind the scenes\". Now the server in this case will just assign the position and rotation variables of the networkObject. These are the two fields we created in the NCW by the way. All generated network objects from the NCW will have a networkObject member variable that you can access from the deriving child. Whenever you assign a field of this object it is replicated across the network if the assigning user is the owner of the object.","title":"BasicCube"},{"location":"GettingStarted/basic-moving-cube-example/#scene-setup","text":"Now that we have done all the network programming required for our end goal, it is time to setup our scene. Create a new scene in unity Create a cube for your floor Set the position of this cube on the x , y , and z to 0 , 0 , 0 respectively Set this cube's scale on the x , y , and z to 25 , 0.1 , 25 respectively Create another cube which will act as the active moving cube Set the position of this cube on the x , y , and z to 0 , 3 , 0 respectively Attach a 3D Rigidbody Component to the cube Attach our BasicCube script to this cube Save the scene as BasicCube Open up the build properties for Unity Add the MultiplayerMenu scene as the first scene Add your BasicCube scene as the second scene","title":"Scene Setup"},{"location":"GettingStarted/basic-moving-cube-example/#test","text":"Now that we have setup our scene and everything else, it is time to test the game. Open the Build Settings Click on Player Settings... Open the Resolution and Presentation section Turn on Run In Background* Go back to Build Settings Click on Build And Run Once the game is open, return to the Unity Editor Open the MultiplayerMenu scene Click the play button Click the Host (127.0.0.1:15937) button on the bottom of the game view Go back to the built game Make sure the host ip address is set to 127.0.0.1 Make sure the host port is set to 15937 Click the Connect button Select the server game instance (Unity Editor) Now if you move around the cube in the editor, you will see the movements replicated to the clients.","title":"Test"},{"location":"GettingStarted/basic-moving-cube-example/#troubleshooting","text":"Getting a null reference exception? The most common user errors with this part of the documentation are: Forgot to turn on Run in Background* Tried pressing the play button in the scene and not loading the Multiplayer Menu scene first Not setting up the multiplayer menu scene as index 0 and the demo scene as index 1","title":"Troubleshooting"},{"location":"GettingStarted/basic-rpc-example/","text":"Basic RPC Example This example is not a continuation of other examples and should be treated as if it were done in a new project. In this example we are going to go over how to use the built in RPC methods inside of Forge Networking Remastered. In this example we are going to make a scene that already has a cube in it, then if anyone presses the up arrow key it will move the cube up, if anyone presses the down arrow key, it will move the cube down. Planning Network Code So, one of the first things we want to think about is our Network Contract . This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will see a cube, if that client or any other connection (server or client) presses the up or down arrow key the cube will move in the appropriate direction for everyone connected: Have a cube already in the scene Press up arrow key to move the cube up via RPC method Press the down arrow key to move the cube down via RPC method Network Contract Wizard Now that we know that we need to sync the position and rotation of a cube, we can design our network contract for that object. We will first open the Network Contract Wizard which is a UI provided by the Bearded Man Studios team to make it easy to design your network contracts in an easy way. To open this menu, go into Unity and select \"Window- Forge Networking- Network Contract Wizard\". Once you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the Network Contract Wizard (NCW) as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the Name fields, the Fields field, and the Remote Procedure Calls field. The Name field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated. The Fields section shows all of the various fields that our network should be aware of. The Remote Procedure Calls field is where you will design any Remote Procedure Call (RPC) function signatures. This is going to be our main area of focus for this example. Setting up the contract option 1 In this option, we will create 2 RPC methods with no arguments. One RPC is to move the cube up and the other is to move the cube down. NOTE: Only pick option 1 or 2 to follow Let's begin by naming our Network Object: Let's set the name for our Network object to MoveCube Click the Add RPC button Name the new RPC MoveUp Click the Add RPC button Name the new RPC MoveDown Click the Save Compile button Setting up the contract option 2 In this option, we will create 1 RPC with 1 argument that denotes the direction to move the cube. NOTE: Only pick option 1 or 2 to follow Let's begin by naming our Network Object: Let's set the name for our Network object to MoveCube Click the Add RPC button Name the new RPC Move Click the arrow to open Arguments next to the RPC name input box Click the green button that appears below the RPC name input box Select Vector3 from the dropdown option list Click the Save Compile button In this example, you may be curious what the Vector3 selection was for. This particular selection was to set the data types that will be sent as arguments to this method. Since we will be sending a direction to move in, this is a Vector3 , that means that we would need to pick it. The order of these type selections (if we had more than one) are explicit. That is to say that the order you select them in, is the order that you would pass argument types in, just as if you were writing a method in C#. Extending Generated Classes When we use the Network Contract Wizard (NCW) we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class that we want to extend from, this class name will be \" MoveCubeBehavior \". The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Let's now create a C# file in Unity and write our basic game logic, we will name this file \" MoveCube \". Open the newly created C# file Add using BeardedManStudios.Forge.Networking.Generated; to the using statements Derive the class from BasicCubeBehavior Write the rest of the logic for the cube as seen below Code if option 1 was selected MoveCube using UnityEngine; using BeardedManStudios.Forge.Networking.Generated; using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Unity; public class MoveCube : MoveCubeBehavior { private void Update() { // Move the cube up in world space if the up arrow was pressed if (Input.GetKeyDown(KeyCode.UpArrow)) networkObject.SendRpc(RPC_MOVE_UP, Receivers.All); // Move the cube down in world space if the down arrow was pressed else if (Input.GetKeyDown(KeyCode.DownArrow)) networkObject.SendRpc(RPC_MOVE_DOWN, Receivers.All); } /// summary /// Used to move the cube that this script is attached to up /// /summary /// param name= args null /param public override void MoveUp(RpcArgs args) { // RPC calls are not made from the main thread for performance, since we // are interacting with Unity enginge objects, we will need to make sure // to run the logic on the main thread MainThreadManager.Run(() = { transform.position += Vector3.up; }); } /// summary /// Used to move the cube that this script is attached to down /// /summary /// param name= args null /param public override void MoveDown(RpcArgs args) { // RPC calls are not made from the main thread for performance, since we // are interacting with Unity engine objects, we will need to make sure // to run the logic on the main thread MainThreadManager.Run(() = { transform.position += Vector3.down; }); } } As you can see from the code snippet above an RPC is called using the networkObject.SendRPC method. The first argument is the name of the method and the second argument is the receivers of the object which could be set to things like AllBuffered, Others, etc. The moment the RPC method is called it is sent on the network to be replicated to the other clients (including server if called from a client). Note : _In this example, it doesn't use a buffered call and it does not actually synchronize the position, so the client should be connected before the cube is moved. Note 2 : Notice that we use MainThreadManager to run the move logic in this example, if you have not used the MainThreadManager before or would like more information about threading in Unity, please view this page . Code if option 2 was selected MoveCube using UnityEngine; using BeardedManStudios.Forge.Networking.Generated; using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Unity; public class MoveCube : MoveCubeBehavior { private void Update() { // Move the cube up in world space if the up arrow was pressed if (Input.GetKeyDown(KeyCode.UpArrow)) networkObject.SendRpc(RPC_MOVE, Receivers.All, Vector3.up); // Move the cube down in world space if the down arrow was pressed else if (Input.GetKeyDown(KeyCode.DownArrow)) networkObject.SendRpc(RPC_MOVE, Receivers.All, Vector3.down); } /// summary /// Used to move the cube that this script is attached to /// /summary /// param name= args /// [0] Vector3 The direction/distance to move this cube by /// /param public override void Move(RpcArgs args) { // RPC calls are not made from the main thread for performance, since we // are interacting with Unity engine objects, we will need to make sure // to run the logic on the main thread MainThreadManager.Run(() = { transform.position += args.GetNext Vector3 (); }); } } As you can see from the code snippet above an RPC is called using the networkObject.SendRPC method. The first argument is the name of the method, the second argument is the receivers of the object which could be set to things like AllBuffered, Others, etc, and the last argument(s) are the arguments for the method. The arguments are mapped to the object[] args of the method in the order that they were sent in. The moment the RPC method is called it is sent on the network to be replicated to the other clients (including server if called from a client). Note : In this example, it doesn't use a buffered call and it does not actually synchronize the position, so the client should be connected before the cube is moved. Note 2 : Notice that we use MainThreadManager to run the move logic in this example, if you have not used the MainThreadManager before or would like more information about threading in Unity, please view this page . Scene Setup Now that we have done all of the network programming required for our end goal, it is time to setup our scene. Create a new scene in unity Create a cube which will act as the active moving cube Set the position of this cube on the x , y , and z to 0 , 0 , 0 respectively Attach our MoveCube script to this cube Save the scene as MoveCube Open up the build properties for Unity Add the MultiplayerMenu scene as the first scene Add your MoveCube scene as the second scene Test Now that we have setup our scene and everything else, it is time to test the game. Open the Build Settings Click on Player Settings... Open the Resolution and Presentation section Turn on Run In Background* Go back to Build Settings Click on Build And Run Once the game is open, return to the Unity Editor Open the MultiplayerMenu scene Click the play button Click the Host (127.0.0.1:15937) button on the bottom of the game view Go back to the built game Make sure the host ip address is set to 127.0.0.1 Make sure the host port is set to 15937 Click the Connect button Select the server instance (Unity Editor) then press the up and down arrow keys Select the client instance then press the up and down arrow keys You will see the server movements replicated to the client and the client movements replicated to the server Troubleshooting Getting a null reference exception? The most common user errors with this part of the documentation are: Forgot to turn on Run in Background* Tried pressing the play button in the scene and not loading the Multiplayer Menu scene first Not setting up the multiplayer menu scene as index 0 and the demo scene as index 1","title":"Basic RPC Example"},{"location":"GettingStarted/basic-rpc-example/#basic-rpc-example","text":"This example is not a continuation of other examples and should be treated as if it were done in a new project. In this example we are going to go over how to use the built in RPC methods inside of Forge Networking Remastered. In this example we are going to make a scene that already has a cube in it, then if anyone presses the up arrow key it will move the cube up, if anyone presses the down arrow key, it will move the cube down.","title":"Basic RPC Example"},{"location":"GettingStarted/basic-rpc-example/#planning-network-code","text":"So, one of the first things we want to think about is our Network Contract . This is basically a fancy word for how we design/setup network communication. It is helpful to imagine our final result to our application so that we can properly design for it. In this application when a client connects it will see a cube, if that client or any other connection (server or client) presses the up or down arrow key the cube will move in the appropriate direction for everyone connected: Have a cube already in the scene Press up arrow key to move the cube up via RPC method Press the down arrow key to move the cube down via RPC method","title":"Planning Network Code"},{"location":"GettingStarted/basic-rpc-example/#network-contract-wizard","text":"Now that we know that we need to sync the position and rotation of a cube, we can design our network contract for that object. We will first open the Network Contract Wizard which is a UI provided by the Bearded Man Studios team to make it easy to design your network contracts in an easy way. To open this menu, go into Unity and select \"Window- Forge Networking- Network Contract Wizard\". Once you have opened this editor you will be presented with a list of all the Network Objects currently available, to learn more about this please see the document on the Network Contract Wizard (NCW) as we will just be going over how to create a network object through the contract wizard. To start, click on the \"Create\" button near the top and you will be presented with the create UI. In here, we have 3 major fields of interest, the Name fields, the Fields field, and the Remote Procedure Calls field. The Name field is where we create the name for our Network Object and behavior, this is a friendly name that should be written in \"Pascal case\" to follow the C# convention since it is going to be a part of the class names that are generated. The Fields section shows all of the various fields that our network should be aware of. The Remote Procedure Calls field is where you will design any Remote Procedure Call (RPC) function signatures. This is going to be our main area of focus for this example.","title":"Network Contract Wizard"},{"location":"GettingStarted/basic-rpc-example/#setting-up-the-contract-option-1","text":"In this option, we will create 2 RPC methods with no arguments. One RPC is to move the cube up and the other is to move the cube down. NOTE: Only pick option 1 or 2 to follow Let's begin by naming our Network Object: Let's set the name for our Network object to MoveCube Click the Add RPC button Name the new RPC MoveUp Click the Add RPC button Name the new RPC MoveDown Click the Save Compile button","title":"Setting up the contract option 1"},{"location":"GettingStarted/basic-rpc-example/#setting-up-the-contract-option-2","text":"In this option, we will create 1 RPC with 1 argument that denotes the direction to move the cube. NOTE: Only pick option 1 or 2 to follow Let's begin by naming our Network Object: Let's set the name for our Network object to MoveCube Click the Add RPC button Name the new RPC Move Click the arrow to open Arguments next to the RPC name input box Click the green button that appears below the RPC name input box Select Vector3 from the dropdown option list Click the Save Compile button In this example, you may be curious what the Vector3 selection was for. This particular selection was to set the data types that will be sent as arguments to this method. Since we will be sending a direction to move in, this is a Vector3 , that means that we would need to pick it. The order of these type selections (if we had more than one) are explicit. That is to say that the order you select them in, is the order that you would pass argument types in, just as if you were writing a method in C#.","title":"Setting up the contract option 2"},{"location":"GettingStarted/basic-rpc-example/#extending-generated-classes","text":"When we use the Network Contract Wizard (NCW) we are actually generating a lot of network code based on what has been input into the editor fields, this actually cuts out a lot of work that you would have to do by hand. There is one class that we want to extend from, this class name will be \" MoveCubeBehavior \". The naming convention for this generated class is _____Behavior where \"_____\" is the name we typed into the NCW. Let's now create a C# file in Unity and write our basic game logic, we will name this file \" MoveCube \". Open the newly created C# file Add using BeardedManStudios.Forge.Networking.Generated; to the using statements Derive the class from BasicCubeBehavior Write the rest of the logic for the cube as seen below","title":"Extending Generated Classes"},{"location":"GettingStarted/basic-rpc-example/#code-if-option-1-was-selected","text":"","title":"Code if option 1 was selected"},{"location":"GettingStarted/basic-rpc-example/#movecube","text":"using UnityEngine; using BeardedManStudios.Forge.Networking.Generated; using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Unity; public class MoveCube : MoveCubeBehavior { private void Update() { // Move the cube up in world space if the up arrow was pressed if (Input.GetKeyDown(KeyCode.UpArrow)) networkObject.SendRpc(RPC_MOVE_UP, Receivers.All); // Move the cube down in world space if the down arrow was pressed else if (Input.GetKeyDown(KeyCode.DownArrow)) networkObject.SendRpc(RPC_MOVE_DOWN, Receivers.All); } /// summary /// Used to move the cube that this script is attached to up /// /summary /// param name= args null /param public override void MoveUp(RpcArgs args) { // RPC calls are not made from the main thread for performance, since we // are interacting with Unity enginge objects, we will need to make sure // to run the logic on the main thread MainThreadManager.Run(() = { transform.position += Vector3.up; }); } /// summary /// Used to move the cube that this script is attached to down /// /summary /// param name= args null /param public override void MoveDown(RpcArgs args) { // RPC calls are not made from the main thread for performance, since we // are interacting with Unity engine objects, we will need to make sure // to run the logic on the main thread MainThreadManager.Run(() = { transform.position += Vector3.down; }); } } As you can see from the code snippet above an RPC is called using the networkObject.SendRPC method. The first argument is the name of the method and the second argument is the receivers of the object which could be set to things like AllBuffered, Others, etc. The moment the RPC method is called it is sent on the network to be replicated to the other clients (including server if called from a client). Note : _In this example, it doesn't use a buffered call and it does not actually synchronize the position, so the client should be connected before the cube is moved. Note 2 : Notice that we use MainThreadManager to run the move logic in this example, if you have not used the MainThreadManager before or would like more information about threading in Unity, please view this page .","title":"MoveCube"},{"location":"GettingStarted/basic-rpc-example/#code-if-option-2-was-selected","text":"","title":"Code if option 2 was selected"},{"location":"GettingStarted/basic-rpc-example/#movecube_1","text":"using UnityEngine; using BeardedManStudios.Forge.Networking.Generated; using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Unity; public class MoveCube : MoveCubeBehavior { private void Update() { // Move the cube up in world space if the up arrow was pressed if (Input.GetKeyDown(KeyCode.UpArrow)) networkObject.SendRpc(RPC_MOVE, Receivers.All, Vector3.up); // Move the cube down in world space if the down arrow was pressed else if (Input.GetKeyDown(KeyCode.DownArrow)) networkObject.SendRpc(RPC_MOVE, Receivers.All, Vector3.down); } /// summary /// Used to move the cube that this script is attached to /// /summary /// param name= args /// [0] Vector3 The direction/distance to move this cube by /// /param public override void Move(RpcArgs args) { // RPC calls are not made from the main thread for performance, since we // are interacting with Unity engine objects, we will need to make sure // to run the logic on the main thread MainThreadManager.Run(() = { transform.position += args.GetNext Vector3 (); }); } } As you can see from the code snippet above an RPC is called using the networkObject.SendRPC method. The first argument is the name of the method, the second argument is the receivers of the object which could be set to things like AllBuffered, Others, etc, and the last argument(s) are the arguments for the method. The arguments are mapped to the object[] args of the method in the order that they were sent in. The moment the RPC method is called it is sent on the network to be replicated to the other clients (including server if called from a client). Note : In this example, it doesn't use a buffered call and it does not actually synchronize the position, so the client should be connected before the cube is moved. Note 2 : Notice that we use MainThreadManager to run the move logic in this example, if you have not used the MainThreadManager before or would like more information about threading in Unity, please view this page .","title":"MoveCube"},{"location":"GettingStarted/basic-rpc-example/#scene-setup","text":"Now that we have done all of the network programming required for our end goal, it is time to setup our scene. Create a new scene in unity Create a cube which will act as the active moving cube Set the position of this cube on the x , y , and z to 0 , 0 , 0 respectively Attach our MoveCube script to this cube Save the scene as MoveCube Open up the build properties for Unity Add the MultiplayerMenu scene as the first scene Add your MoveCube scene as the second scene","title":"Scene Setup"},{"location":"GettingStarted/basic-rpc-example/#test","text":"Now that we have setup our scene and everything else, it is time to test the game. Open the Build Settings Click on Player Settings... Open the Resolution and Presentation section Turn on Run In Background* Go back to Build Settings Click on Build And Run Once the game is open, return to the Unity Editor Open the MultiplayerMenu scene Click the play button Click the Host (127.0.0.1:15937) button on the bottom of the game view Go back to the built game Make sure the host ip address is set to 127.0.0.1 Make sure the host port is set to 15937 Click the Connect button Select the server instance (Unity Editor) then press the up and down arrow keys Select the client instance then press the up and down arrow keys You will see the server movements replicated to the client and the client movements replicated to the server","title":"Test"},{"location":"GettingStarted/basic-rpc-example/#troubleshooting","text":"Getting a null reference exception? The most common user errors with this part of the documentation are: Forgot to turn on Run in Background* Tried pressing the play button in the scene and not loading the Multiplayer Menu scene first Not setting up the multiplayer menu scene as index 0 and the demo scene as index 1","title":"Troubleshooting"},{"location":"GettingStarted/getting-started/","text":"Getting Started The following is collection of examples/tutorials to get you up and running with Forge Networking. Our goal with these examples are to help you learn the basics of the engine quickly through guided step by step processes. We do cover more in-depth explanations of the various components of the engine outside of the examples, however we do suggest going through these examples first before taking a deeper dive into the complexities and extensions of the engine found in other sections of this documentation. Basic Moving Cube Example Basic RPC Example Basic Instantiation Example Jump Start Guide Game Lobby Example Want to watch some Jumpstart videos?","title":"Getting Started"},{"location":"GettingStarted/getting-started/#getting-started","text":"The following is collection of examples/tutorials to get you up and running with Forge Networking. Our goal with these examples are to help you learn the basics of the engine quickly through guided step by step processes. We do cover more in-depth explanations of the various components of the engine outside of the examples, however we do suggest going through these examples first before taking a deeper dive into the complexities and extensions of the engine found in other sections of this documentation. Basic Moving Cube Example Basic RPC Example Basic Instantiation Example Jump Start Guide Game Lobby Example","title":"Getting Started"},{"location":"GettingStarted/getting-started/#want-to-watch-some-jumpstart-videos","text":"","title":"Want to watch some Jumpstart videos?"},{"location":"GettingStarted/jump-start-guide/","text":"Jump Start Guide This example will go through all of the major uses of Forge Networking Remastered. You will learn the basic building blocks required to build any online multiplayer game using Forge Networking Remastered (FNR). Introduction The game we will be creating for this example is very simple. We will have two or more players that can see each other as capsules and we will have a volume (trigger), in this trigger if our player activates it (triggers it) then it will spawn a sphere to the center of the map that will have a rigidbody and random x and z force. Note that the trigger will need to be destroyed when the ball is spawned in order to prevent it from spawning more than one sphere. When the sphere is collided with y the player, then the sphere is destroyed and we add a point to the player who touched the sphere. Very First Step The first step before adding any networking to your game is to identify where the critical points to add networking will be. Below is a list of information we know that will need to be sent across the network in order for the game to play as expected on all connections. Spawn player Sync player positions Sync player names Destroy trigger after touch Spawn sphere Sync sphere position Change sphere velocity on spawn Add points for colliding with sphere Change sphere position after collision Next we can go through each of our required network fields and determine which ones should be done with an RPC, network instantiate, network destroy, and which ones should be done by synchronizing a variable. Instantiate Spawn player Variable Sync player positions RPC Sync player names Destroy Remove trigger after touch Instantiate Spawn sphere Variable Sync sphere position RPC Change sphere velocity on spawn RPC Show the last person who got the ball RPC Change sphere position and velocity after collision By doing this we are easily able to see what we should do next when we move onto the Network Contract Wizard (NCW). Setup the Game Next, before we setup our networking logic, we will want to setup our base game and all of it's objects and prefabs (No scripting yet). First we will create the basic world for our players to run around in. Create folder: Scenes Create folder: Scripts Create folder: Prefabs Create folder: Materials Create a new scene Delete the Main Camera Save your scene as a new scene into Scenes folder Create a material in Materials folder Name: Trigger Color: 0, 255, 0, 128 Set Rendering Mode to Transparent Create a material in Materials folder Name: GameBall Color: 0, 0, 255, 255 Do the following in the Scene we just created. Create a cube: Position: 0, 0, 0 Rotation: 0, 0, 0 Scale: 25, 0.1, 25 Name: Floor Create a cube Position: -12.5, 5, 0 Rotation: 0, 0, 0 Scale: 0.1, 10, 25 Name: Left Wall Create a cube Position: 12.5, 5, 0 Rotation: 0, 0, 0 Scale: 0.1, 10, 25 Name: Right Wall Create a cube Position: 0, 5, -12.5 Rotation: 0, 0, 0 Scale: 25, 10, 0.1 Name: Front Wall Create a cube Position: 0, 5, 12.5 Rotation: 0, 0, 0 Scale: 25, 10, 0.1 Name: Back Wall Create a cube Position: 7.5, 5, 7.5 Rotation: 0, 0, 0 Scale: 10, 10, 10 Name: Start Trigger Set Material to the Trigger material we created Check the Is Trigger box in the box collider component on this object Create a sphere Position: 0, 10, 0 Rotation: 0, 0, 0 Scale: 1, 1, 1 Name: GameBall Set Material to the GameBall material we created Add a Rigidbody component Save as a Prefab in the Prefabs folder Delete from scene Create an empty Game Object Position: 0, 0, 0 Rotation: 0, 0, 0 Scale: 1, 1, 1 Name: Game Logic Select the menu item Game Object UI Text The Text that is created in the Hierarchy Rename it to Last Scored Change the Text field to be empty Set the Anchor Preset to Top Left (this is the one with the top left being highlighted in the anchor image) e. Set the Pivot X to 0 Set the Pivot Y to 1 Set Pos X to 0 Set Pos Y to 0 Set Pos Z to 0 Set Width to 500 Save the scene Now we have completed the setup for our game, let's setup our Build Settings Open Build Settings from File Build Settings (Ctrl + Shift + B on windows) Add MultiplayerMenu scene as the 0th scene index Add your newly saved scene as the 1st index Click Player Settings... Turn on Run In Background Now all that is left to do is setup our Player prefab and then we will be ready to jump into setting up our network. In Unity select Assets Import Package Characters Click the Import button Open the Standard Assets Characters FirstPersonCharacter Prefabs directory Drag the FPSController prefab into the scene Rename the prefab to Player Add a Mesh Filter component Add a Mesh Renderer component Select the Capsule as the Mesh in the MeshFilter component Open the Materials drop down in the Mesh Renderer Select Default-Material in Element 0 Add a Sphere Collider Set Y to -0.5 Set Radius to 0.5 Add another Sphere Collider Set Y to 0.5 Set Radius to 0.5 Drag the Player GameObject from the Hierarchy into the Prefabs folder that we made in the beginning Delete the Player Game Object from the scene Save the project The reason we are adding 2 sphere Colliders is because (at the time of this writing) the Character Controller is not reliable for detecting collisions. You have to \"rub\" up on the object a bit before it is detected. By adding the sphere colliders to our character, this issue will be resolved. Now you are ready to start setting up your network contract using the Network Contract Wizard . Network Contract Wizard The Network Contract Wizard (NCW) is responsible for creating the blueprint of the network communication. We will use this UI to setup the basic classes, fields, and remote procedure calls needed for our network communication. To get started, open the Network Contract Wizard UI by going to Window Forge Networking Network Contract Wizard within Unity. In this window you will be presented with all the current network classes. If you included the Bearded Man Studios Inc examples folder then you should see a couple pre-made options initially. Now let's get started on making the network contract for our simple game: Click the Create button Type in Player into the name box Click the Add Field button Type position into the text box Select the drop down Select VECTOR3 from the options Click the Interpolate button and leave the value at 0.15 Click the Add RPC button Type UpdateName into the text field Open the Arguments cascade 1.Click the button Type newName into the text field Click the drop down iv. Select STRING from the drop down Click Save Compile What this will do is create and modify some classes in the Generated folder of your project. Before we continue to add the other network contracts, let's setup our Player class. Open the Scripts folder Create a new C# script named Player Open the Prefabs folder and select the Player prefab Click Add Component Add the Player script to the prefab Select the Scripts folder Open the Player.cs script you just created Insert the following code Player.cs** // We use this namespace as it is where our PlayerBehavior was generated using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Generated; using UnityEngine; using UnityStandardAssets.Characters.FirstPerson; // We extend PlayerBehavior which extends NetworkBehavior which extends MonoBehaviour public class Player : PlayerBehavior { private string[] nameParts = new string[] { crazy , cat , dog , homie , bobble , mr , ms , mrs , castle , flip , flop }; public string Name { get; private set; } protected override void NetworkStart() { base.NetworkStart(); if (!networkObject.IsOwner) { // Don't render through a camera that is not ours // Don't listen to audio through a listener that is not ours transform.GetChild(0).gameObject.SetActive(false); // Don't accept inputs from objects that are not ours GetComponent FirstPersonController ().enabled = false; // There is no reason to try and simulate physics since the position is // being sent across the network anyway Destroy(GetComponent Rigidbody ()); } // Assign the name when this object is setup on the network ChangeName(); } public void ChangeName() { // Only the owning client of this object can assign the name if (!networkObject.IsOwner) return; // Get a random index for the first name int first = Random.Range(0, nameParts.Length - 1); // Get a random index for the last name int last = Random.Range(0, nameParts.Length - 1); // Assign the name to the random selection Name = nameParts[first] + + nameParts[last]; // Send an RPC to let everyone know what the name is for this player // We use AllBuffered so that if people come late they will get the // latest name for this object // We pass in Name for the args because we have 1 argument that is to // be a string as it is set in the NCW networkObject.SendRpc(RPC_UPDATE_NAME, Receivers.AllBuffered, Name); } // Default Unity update method private void Update() { // Check to see if we are the owner of this player if (!networkObject.IsOwner) { // If we are not the owner then we set the position to the // position that is syndicated across the network for this player transform.position = networkObject.position; return; } // When our position changes the networkObject.position will detect the // change based on this assignment automatically, this data will then be // syndicated across the network on the next update pass for this networkObject networkObject.position = transform.position; } // Override the abstract RPC method that we made in the NCW public override void UpdateName(RpcArgs args) { // Since there is only 1 argument and it is a string we can safely // cast the first argument to a string knowing that it is going to // be the name for this player Name = args.GetNext string (); } } This is all the code we need to allow for all of the connections to see the movement of the players. The next thing we need is to be able to actually instantiate our Player prefab since it will not be in the scene at the start of the game. To do this let's open the NCW window again. Click the Create button Type in GameLogic in the name box Click the Add RPC button Type PlayerScored into the text field Open the Arguments cascade Click the button Type playerName into the text field Click the drop down iv. Select STRING from the drop down Click Save Compile What this will do is create and modify some classes in the Generated folder of your project. Before we continue to add the other network contracts, let's setup our GameLogic class. Open the Scripts folder Create a new C# script named GameLogic Select the Game Logic Game Object from the Hierarchy of our previously saved scene Click Add Component Add the GameLogic script to the Game Object Select the Scripts folder Open the GameLogic.cs script you just created Insert the following code GameManager.cs // We use this namespace as it is where our GameLogicBehavior was generated using BeardedManStudios.Forge.Networking.Generated; using BeardedManStudios.Forge.Networking.Unity; using UnityEngine; using UnityEngine.UI; // We extend GameLogicBehavior which extends NetworkBehavior which extends MonoBehaviour public class GameLogic : GameLogicBehavior { public Text scoreLabel; private void Start() { // This will be called on every client, so each client will essentially instantiate // their own player on the network. We also pass in the position we want them to spawn at NetworkManager.Instance.InstantiatePlayer(position: new Vector3(0, 5, 0)); } // Override the abstract RPC method that we made in the NCW public override void PlayerScored(RpcArgs args) { // Since there is only 1 argument and it is a string we can safely // cast the first argument to a string knowing that it is going to // be the name for the scoring player string playerName = args.GetNext string (); // Update the UI to show the last player that scored scoreLabel.text = Last player to score was: + playerName; } } Now we are able to not only spawn the player, but we are also able to print out the last player that scored to the screen. Talking about scoring, we possibly want to get the ball rolling (if you would excuse the expression) and instantiate the ball and serialize it's position to all the clients. However just before that, lets fill out our scoreLabel object on our Game Logic Game Object. Select the Game Logic from the hierarchy Drag the Last Scored UI Game Object from the hierarchy to the Score Label field on the GameLogic script Okay, now we are actually ready to make the ball now! So let's start by opening up the NCW window once again. Click the Create button Type in GameBall into the name box Click the Add Field button Type position into the text box Select the drop down Select VECTOR3 from the options Click the Interpolate button and leave the value at 0.15 Click Save Compile What this will do is create and modify some classes in the Generated folder of your project. Before we continue to add the other network contracts, let's setup our GameBall class. Open the Scripts folder Create a new C# script named GameBall Open the Prefabs folder and select the GameBall prefab Click Add Component Add the GameBall script to the prefab Select the Scripts folder Open the GameBall.cs script you just created Insert the following code GameBall.cs // We use this namespace as it is where our BallBehavior was generated using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Generated; using BeardedManStudios.Forge.Networking.Unity; using UnityEngine; // We extend BallBehavior which extends NetworkBehavior which extends MonoBehaviour public class GameBall : GameBallBehavior { private Rigidbody rigidbodyRef; private GameLogic gameLogic; private void Awake() { rigidbodyRef = GetComponent Rigidbody (); gameLogic = FindObjectOfType GameLogic (); } // Default Unity update method private void Update() { // Check to see if we are the owner of this ball if (!networkObject.IsOwner) { // If we are not the owner then we set the position to the // position that is syndicated across the network for this ball transform.position = networkObject.position; return; } // When our position changes the networkObject.position will detect the // change based on this assignment automatically, this data will then be // syndicated across the network on the next update pass for this networkObject networkObject.position = transform.position; } public void Reset() { // Move the ball to 0, 10, 0 transform.position = Vector3.up * 10; // Reset the velocity for this object to zero rigidbodyRef.velocity = Vector3.zero; // Create a random force to apply to this object between 300 to 500 or -300 to -500 Vector3 force = new Vector3(0, 0, 0); force.x = Random.Range(300, 500); force.z = Random.Range(300, 500); // Randomly invert along the number line by 50% if (Random.value 0.5f) force.x *= -1; if (Random.value 0.5f) force.z *= -1; // Add the random force to the ball rigidbodyRef.AddForce(force); } private void OnCollisionEnter(Collision c) { // We are making this authoritative by only // allowing the server to call it if (!networkObject.IsServer) return; // Only move if a player touched the ball if (c.GetComponent Player () == null) return; // Call an RPC on the Game Logic to print the player's name as the last // player to touch the ball gameLogic.networkObject.SendRpc(GameLogicBehavior.RPC_PLAYER_SCORED, Receivers.All, c.GetComponent Player ().Name); // Reset the ball Reset(); } } With the ball complete, we are finally ready to move onto the last script that we will need to create, the behavior for the trigger that starts the whole game! Open the Scripts folder Create a new C# script named GameTrigger Select the Start Trigger Game Object from the Hierarchy of our previously saved scene Click Add Component Add the GameTrigger script to the Game Object Select the Scripts folder Open the GameTrigger.cs script you just created Insert the following code GameTrigger.cs using BeardedManStudios.Forge.Networking.Unity; using UnityEngine; public class GameTrigger : MonoBehaviour { private bool started; private void Update() { // If the game started we will remove this trigger from the scene if (FindObjectOfType GameBall () != null) Destroy(gameObject); } private void OnTriggerEnter(Collider c) { // Since we added 2 sphere colliders to the player, we need to // make sure to only trigger this 1 time if (started) return; // Only allow the server player to start the game so that the // server is the owner of the ball, otherwise if a client is the // owner of the ball, if they disconnect, the ball will be destroyed if (!NetworkManager.Instance.IsServer) return; Player player = c.GetComponent Player (); if (player == null) return; started = true; // We need to create the ball on the network GameBall ball = NetworkManager.Instance.InstantiateGameBall() as GameBall; // Reset the ball position and give it a random velocity ball.Reset(); // We no longer need this trigger, the game has started Destroy(gameObject); } } Finalization of our game! Now that we have finished all of the network code, we need to tell Forge what prefabs are suppose to be instantiated when we make those NetworkManager.Instance.Instantiat... calls. Open Bearded Man Studios Inc Prefabs Select the prefab named NetworkManager Locate the various empty fields in the NetworkManager component that is attached to this prefab In the GameBall Network Object array field, put the GameBall prefab from the Prefabs folder as the Element 0 (0th index) In the Player Network Object array field, put the Player prefab from the Prefabs folder as the Element 0 (0th index) Congratulations You have completed the steps for this tutorial. All that is left is to build, run and test it out. To do this just build the project as you normally would do within the Unity Editor. Build the project Run 2 instances of the project Select Host in one instance Click Connect in the second instance You may be prompted to allow access to the application on the firewall, which you will need to accept Troubleshooting Getting a null reference exception? The most common user errors with this part of the documentation are: Forgot to turn on Run in Background* Tried pressing the play button in the scene and not loading the Multiplayer Menu scene first Not setting up the multiplayer menu scene as index 0 and the demo scene as index 1","title":"Jump Start Guide"},{"location":"GettingStarted/jump-start-guide/#jump-start-guide","text":"This example will go through all of the major uses of Forge Networking Remastered. You will learn the basic building blocks required to build any online multiplayer game using Forge Networking Remastered (FNR).","title":"Jump Start Guide"},{"location":"GettingStarted/jump-start-guide/#introduction","text":"The game we will be creating for this example is very simple. We will have two or more players that can see each other as capsules and we will have a volume (trigger), in this trigger if our player activates it (triggers it) then it will spawn a sphere to the center of the map that will have a rigidbody and random x and z force. Note that the trigger will need to be destroyed when the ball is spawned in order to prevent it from spawning more than one sphere. When the sphere is collided with y the player, then the sphere is destroyed and we add a point to the player who touched the sphere.","title":"Introduction"},{"location":"GettingStarted/jump-start-guide/#very-first-step","text":"The first step before adding any networking to your game is to identify where the critical points to add networking will be. Below is a list of information we know that will need to be sent across the network in order for the game to play as expected on all connections. Spawn player Sync player positions Sync player names Destroy trigger after touch Spawn sphere Sync sphere position Change sphere velocity on spawn Add points for colliding with sphere Change sphere position after collision Next we can go through each of our required network fields and determine which ones should be done with an RPC, network instantiate, network destroy, and which ones should be done by synchronizing a variable. Instantiate Spawn player Variable Sync player positions RPC Sync player names Destroy Remove trigger after touch Instantiate Spawn sphere Variable Sync sphere position RPC Change sphere velocity on spawn RPC Show the last person who got the ball RPC Change sphere position and velocity after collision By doing this we are easily able to see what we should do next when we move onto the Network Contract Wizard (NCW).","title":"Very First Step"},{"location":"GettingStarted/jump-start-guide/#setup-the-game","text":"Next, before we setup our networking logic, we will want to setup our base game and all of it's objects and prefabs (No scripting yet). First we will create the basic world for our players to run around in. Create folder: Scenes Create folder: Scripts Create folder: Prefabs Create folder: Materials Create a new scene Delete the Main Camera Save your scene as a new scene into Scenes folder Create a material in Materials folder Name: Trigger Color: 0, 255, 0, 128 Set Rendering Mode to Transparent Create a material in Materials folder Name: GameBall Color: 0, 0, 255, 255 Do the following in the Scene we just created. Create a cube: Position: 0, 0, 0 Rotation: 0, 0, 0 Scale: 25, 0.1, 25 Name: Floor Create a cube Position: -12.5, 5, 0 Rotation: 0, 0, 0 Scale: 0.1, 10, 25 Name: Left Wall Create a cube Position: 12.5, 5, 0 Rotation: 0, 0, 0 Scale: 0.1, 10, 25 Name: Right Wall Create a cube Position: 0, 5, -12.5 Rotation: 0, 0, 0 Scale: 25, 10, 0.1 Name: Front Wall Create a cube Position: 0, 5, 12.5 Rotation: 0, 0, 0 Scale: 25, 10, 0.1 Name: Back Wall Create a cube Position: 7.5, 5, 7.5 Rotation: 0, 0, 0 Scale: 10, 10, 10 Name: Start Trigger Set Material to the Trigger material we created Check the Is Trigger box in the box collider component on this object Create a sphere Position: 0, 10, 0 Rotation: 0, 0, 0 Scale: 1, 1, 1 Name: GameBall Set Material to the GameBall material we created Add a Rigidbody component Save as a Prefab in the Prefabs folder Delete from scene Create an empty Game Object Position: 0, 0, 0 Rotation: 0, 0, 0 Scale: 1, 1, 1 Name: Game Logic Select the menu item Game Object UI Text The Text that is created in the Hierarchy Rename it to Last Scored Change the Text field to be empty Set the Anchor Preset to Top Left (this is the one with the top left being highlighted in the anchor image) e. Set the Pivot X to 0 Set the Pivot Y to 1 Set Pos X to 0 Set Pos Y to 0 Set Pos Z to 0 Set Width to 500 Save the scene Now we have completed the setup for our game, let's setup our Build Settings Open Build Settings from File Build Settings (Ctrl + Shift + B on windows) Add MultiplayerMenu scene as the 0th scene index Add your newly saved scene as the 1st index Click Player Settings... Turn on Run In Background Now all that is left to do is setup our Player prefab and then we will be ready to jump into setting up our network. In Unity select Assets Import Package Characters Click the Import button Open the Standard Assets Characters FirstPersonCharacter Prefabs directory Drag the FPSController prefab into the scene Rename the prefab to Player Add a Mesh Filter component Add a Mesh Renderer component Select the Capsule as the Mesh in the MeshFilter component Open the Materials drop down in the Mesh Renderer Select Default-Material in Element 0 Add a Sphere Collider Set Y to -0.5 Set Radius to 0.5 Add another Sphere Collider Set Y to 0.5 Set Radius to 0.5 Drag the Player GameObject from the Hierarchy into the Prefabs folder that we made in the beginning Delete the Player Game Object from the scene Save the project The reason we are adding 2 sphere Colliders is because (at the time of this writing) the Character Controller is not reliable for detecting collisions. You have to \"rub\" up on the object a bit before it is detected. By adding the sphere colliders to our character, this issue will be resolved. Now you are ready to start setting up your network contract using the Network Contract Wizard .","title":"Setup the Game"},{"location":"GettingStarted/jump-start-guide/#network-contract-wizard","text":"The Network Contract Wizard (NCW) is responsible for creating the blueprint of the network communication. We will use this UI to setup the basic classes, fields, and remote procedure calls needed for our network communication. To get started, open the Network Contract Wizard UI by going to Window Forge Networking Network Contract Wizard within Unity. In this window you will be presented with all the current network classes. If you included the Bearded Man Studios Inc examples folder then you should see a couple pre-made options initially. Now let's get started on making the network contract for our simple game: Click the Create button Type in Player into the name box Click the Add Field button Type position into the text box Select the drop down Select VECTOR3 from the options Click the Interpolate button and leave the value at 0.15 Click the Add RPC button Type UpdateName into the text field Open the Arguments cascade 1.Click the button Type newName into the text field Click the drop down iv. Select STRING from the drop down Click Save Compile What this will do is create and modify some classes in the Generated folder of your project. Before we continue to add the other network contracts, let's setup our Player class. Open the Scripts folder Create a new C# script named Player Open the Prefabs folder and select the Player prefab Click Add Component Add the Player script to the prefab Select the Scripts folder Open the Player.cs script you just created Insert the following code","title":"Network Contract Wizard"},{"location":"GettingStarted/jump-start-guide/#playercs","text":"// We use this namespace as it is where our PlayerBehavior was generated using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Generated; using UnityEngine; using UnityStandardAssets.Characters.FirstPerson; // We extend PlayerBehavior which extends NetworkBehavior which extends MonoBehaviour public class Player : PlayerBehavior { private string[] nameParts = new string[] { crazy , cat , dog , homie , bobble , mr , ms , mrs , castle , flip , flop }; public string Name { get; private set; } protected override void NetworkStart() { base.NetworkStart(); if (!networkObject.IsOwner) { // Don't render through a camera that is not ours // Don't listen to audio through a listener that is not ours transform.GetChild(0).gameObject.SetActive(false); // Don't accept inputs from objects that are not ours GetComponent FirstPersonController ().enabled = false; // There is no reason to try and simulate physics since the position is // being sent across the network anyway Destroy(GetComponent Rigidbody ()); } // Assign the name when this object is setup on the network ChangeName(); } public void ChangeName() { // Only the owning client of this object can assign the name if (!networkObject.IsOwner) return; // Get a random index for the first name int first = Random.Range(0, nameParts.Length - 1); // Get a random index for the last name int last = Random.Range(0, nameParts.Length - 1); // Assign the name to the random selection Name = nameParts[first] + + nameParts[last]; // Send an RPC to let everyone know what the name is for this player // We use AllBuffered so that if people come late they will get the // latest name for this object // We pass in Name for the args because we have 1 argument that is to // be a string as it is set in the NCW networkObject.SendRpc(RPC_UPDATE_NAME, Receivers.AllBuffered, Name); } // Default Unity update method private void Update() { // Check to see if we are the owner of this player if (!networkObject.IsOwner) { // If we are not the owner then we set the position to the // position that is syndicated across the network for this player transform.position = networkObject.position; return; } // When our position changes the networkObject.position will detect the // change based on this assignment automatically, this data will then be // syndicated across the network on the next update pass for this networkObject networkObject.position = transform.position; } // Override the abstract RPC method that we made in the NCW public override void UpdateName(RpcArgs args) { // Since there is only 1 argument and it is a string we can safely // cast the first argument to a string knowing that it is going to // be the name for this player Name = args.GetNext string (); } } This is all the code we need to allow for all of the connections to see the movement of the players. The next thing we need is to be able to actually instantiate our Player prefab since it will not be in the scene at the start of the game. To do this let's open the NCW window again. Click the Create button Type in GameLogic in the name box Click the Add RPC button Type PlayerScored into the text field Open the Arguments cascade Click the button Type playerName into the text field Click the drop down iv. Select STRING from the drop down Click Save Compile What this will do is create and modify some classes in the Generated folder of your project. Before we continue to add the other network contracts, let's setup our GameLogic class. Open the Scripts folder Create a new C# script named GameLogic Select the Game Logic Game Object from the Hierarchy of our previously saved scene Click Add Component Add the GameLogic script to the Game Object Select the Scripts folder Open the GameLogic.cs script you just created Insert the following code","title":"Player.cs**"},{"location":"GettingStarted/jump-start-guide/#gamemanagercs","text":"// We use this namespace as it is where our GameLogicBehavior was generated using BeardedManStudios.Forge.Networking.Generated; using BeardedManStudios.Forge.Networking.Unity; using UnityEngine; using UnityEngine.UI; // We extend GameLogicBehavior which extends NetworkBehavior which extends MonoBehaviour public class GameLogic : GameLogicBehavior { public Text scoreLabel; private void Start() { // This will be called on every client, so each client will essentially instantiate // their own player on the network. We also pass in the position we want them to spawn at NetworkManager.Instance.InstantiatePlayer(position: new Vector3(0, 5, 0)); } // Override the abstract RPC method that we made in the NCW public override void PlayerScored(RpcArgs args) { // Since there is only 1 argument and it is a string we can safely // cast the first argument to a string knowing that it is going to // be the name for the scoring player string playerName = args.GetNext string (); // Update the UI to show the last player that scored scoreLabel.text = Last player to score was: + playerName; } } Now we are able to not only spawn the player, but we are also able to print out the last player that scored to the screen. Talking about scoring, we possibly want to get the ball rolling (if you would excuse the expression) and instantiate the ball and serialize it's position to all the clients. However just before that, lets fill out our scoreLabel object on our Game Logic Game Object. Select the Game Logic from the hierarchy Drag the Last Scored UI Game Object from the hierarchy to the Score Label field on the GameLogic script Okay, now we are actually ready to make the ball now! So let's start by opening up the NCW window once again. Click the Create button Type in GameBall into the name box Click the Add Field button Type position into the text box Select the drop down Select VECTOR3 from the options Click the Interpolate button and leave the value at 0.15 Click Save Compile What this will do is create and modify some classes in the Generated folder of your project. Before we continue to add the other network contracts, let's setup our GameBall class. Open the Scripts folder Create a new C# script named GameBall Open the Prefabs folder and select the GameBall prefab Click Add Component Add the GameBall script to the prefab Select the Scripts folder Open the GameBall.cs script you just created Insert the following code","title":"GameManager.cs"},{"location":"GettingStarted/jump-start-guide/#gameballcs","text":"// We use this namespace as it is where our BallBehavior was generated using BeardedManStudios.Forge.Networking; using BeardedManStudios.Forge.Networking.Generated; using BeardedManStudios.Forge.Networking.Unity; using UnityEngine; // We extend BallBehavior which extends NetworkBehavior which extends MonoBehaviour public class GameBall : GameBallBehavior { private Rigidbody rigidbodyRef; private GameLogic gameLogic; private void Awake() { rigidbodyRef = GetComponent Rigidbody (); gameLogic = FindObjectOfType GameLogic (); } // Default Unity update method private void Update() { // Check to see if we are the owner of this ball if (!networkObject.IsOwner) { // If we are not the owner then we set the position to the // position that is syndicated across the network for this ball transform.position = networkObject.position; return; } // When our position changes the networkObject.position will detect the // change based on this assignment automatically, this data will then be // syndicated across the network on the next update pass for this networkObject networkObject.position = transform.position; } public void Reset() { // Move the ball to 0, 10, 0 transform.position = Vector3.up * 10; // Reset the velocity for this object to zero rigidbodyRef.velocity = Vector3.zero; // Create a random force to apply to this object between 300 to 500 or -300 to -500 Vector3 force = new Vector3(0, 0, 0); force.x = Random.Range(300, 500); force.z = Random.Range(300, 500); // Randomly invert along the number line by 50% if (Random.value 0.5f) force.x *= -1; if (Random.value 0.5f) force.z *= -1; // Add the random force to the ball rigidbodyRef.AddForce(force); } private void OnCollisionEnter(Collision c) { // We are making this authoritative by only // allowing the server to call it if (!networkObject.IsServer) return; // Only move if a player touched the ball if (c.GetComponent Player () == null) return; // Call an RPC on the Game Logic to print the player's name as the last // player to touch the ball gameLogic.networkObject.SendRpc(GameLogicBehavior.RPC_PLAYER_SCORED, Receivers.All, c.GetComponent Player ().Name); // Reset the ball Reset(); } } With the ball complete, we are finally ready to move onto the last script that we will need to create, the behavior for the trigger that starts the whole game! Open the Scripts folder Create a new C# script named GameTrigger Select the Start Trigger Game Object from the Hierarchy of our previously saved scene Click Add Component Add the GameTrigger script to the Game Object Select the Scripts folder Open the GameTrigger.cs script you just created Insert the following code","title":"GameBall.cs"},{"location":"GettingStarted/jump-start-guide/#gametriggercs","text":"using BeardedManStudios.Forge.Networking.Unity; using UnityEngine; public class GameTrigger : MonoBehaviour { private bool started; private void Update() { // If the game started we will remove this trigger from the scene if (FindObjectOfType GameBall () != null) Destroy(gameObject); } private void OnTriggerEnter(Collider c) { // Since we added 2 sphere colliders to the player, we need to // make sure to only trigger this 1 time if (started) return; // Only allow the server player to start the game so that the // server is the owner of the ball, otherwise if a client is the // owner of the ball, if they disconnect, the ball will be destroyed if (!NetworkManager.Instance.IsServer) return; Player player = c.GetComponent Player (); if (player == null) return; started = true; // We need to create the ball on the network GameBall ball = NetworkManager.Instance.InstantiateGameBall() as GameBall; // Reset the ball position and give it a random velocity ball.Reset(); // We no longer need this trigger, the game has started Destroy(gameObject); } } Finalization of our game! Now that we have finished all of the network code, we need to tell Forge what prefabs are suppose to be instantiated when we make those NetworkManager.Instance.Instantiat... calls. Open Bearded Man Studios Inc Prefabs Select the prefab named NetworkManager Locate the various empty fields in the NetworkManager component that is attached to this prefab In the GameBall Network Object array field, put the GameBall prefab from the Prefabs folder as the Element 0 (0th index) In the Player Network Object array field, put the Player prefab from the Prefabs folder as the Element 0 (0th index)","title":"GameTrigger.cs"},{"location":"GettingStarted/jump-start-guide/#congratulations","text":"You have completed the steps for this tutorial. All that is left is to build, run and test it out. To do this just build the project as you normally would do within the Unity Editor. Build the project Run 2 instances of the project Select Host in one instance Click Connect in the second instance You may be prompted to allow access to the application on the firewall, which you will need to accept","title":"Congratulations"},{"location":"GettingStarted/jump-start-guide/#troubleshooting","text":"Getting a null reference exception? The most common user errors with this part of the documentation are: Forgot to turn on Run in Background* Tried pressing the play button in the scene and not loading the Multiplayer Menu scene first Not setting up the multiplayer menu scene as index 0 and the demo scene as index 1","title":"Troubleshooting"},{"location":"MasterServer/connecting-to-master-server/","text":"Connecting to Master Server If you have not already, we would suggest reviewing the Master Server Quick Start documentation to get familiar with the Master Server and to setup the stand alone executable. When you first initialize your NetworkManager (as seen in MultiplayerMenu.cs ) you will need to provide it with the NetWorker that you wish to use for standard game network communications. To do this the NetworkManager has a method MasterServerRegisterData that you can use in order to get the registration data object to allow you to register your game server with the Master Server. Below is an example of how to use the MasterServerRegisterData method to generate the json data needed to register the game server. string serverId = myGame ; string serverName = Forge Game ; string type = Deathmatch ; string mode = Teams ; string comment = Demo comment... ; bool useElo = false; int eloRequired = 0; JSONNode masterServerData = NetworkManager.Instance.MasterServerRegisterData(networker, serverId, serverName, type, mode, comment, useElo, eloRequired); You may be curious what to do next with this data and the answer is to send it into the NetworkManager's Initialize method as seen below. // This should be the IP address of the machine that your master server is hosted on string masterServerHost = 127.0.0.1 ; // This can be left as the default port (15940) if you did not change it when hosting the master server ushort masterServerPort = 15940; NetworkManager.Instance.Initialize(networker, masterServerHost, masterServerPort, masterServerData); With all of this setup your game server should now be automatically registered on the Master Server once this method is called.","title":"Connecting to Master Server"},{"location":"MasterServer/connecting-to-master-server/#connecting-to-master-server","text":"If you have not already, we would suggest reviewing the Master Server Quick Start documentation to get familiar with the Master Server and to setup the stand alone executable. When you first initialize your NetworkManager (as seen in MultiplayerMenu.cs ) you will need to provide it with the NetWorker that you wish to use for standard game network communications. To do this the NetworkManager has a method MasterServerRegisterData that you can use in order to get the registration data object to allow you to register your game server with the Master Server. Below is an example of how to use the MasterServerRegisterData method to generate the json data needed to register the game server. string serverId = myGame ; string serverName = Forge Game ; string type = Deathmatch ; string mode = Teams ; string comment = Demo comment... ; bool useElo = false; int eloRequired = 0; JSONNode masterServerData = NetworkManager.Instance.MasterServerRegisterData(networker, serverId, serverName, type, mode, comment, useElo, eloRequired); You may be curious what to do next with this data and the answer is to send it into the NetworkManager's Initialize method as seen below. // This should be the IP address of the machine that your master server is hosted on string masterServerHost = 127.0.0.1 ; // This can be left as the default port (15940) if you did not change it when hosting the master server ushort masterServerPort = 15940; NetworkManager.Instance.Initialize(networker, masterServerHost, masterServerPort, masterServerData); With all of this setup your game server should now be automatically registered on the Master Server once this method is called.","title":"Connecting to Master Server"},{"location":"MasterServer/getting-host-list/","text":"Getting Host List From Master Server If you have not already, we would suggest reviewing the Master Server Quick Start documentation to get familiar with the Master Server and to setup the stand alone executable and then reviewing Connecting to Master Server to learn how to register your game server on the master server. Request stages There are a few stages when requesting the list of servers from the master server: Connect to Master Server Create a JSONNode request Send the request to the server Get response from the server Parse response from server Implement your code (1) So the very first thing you have to do is to connect to the master server. We have created a helper class to get you doing this quickly: // TODO: This will be the address of the machine your master server is running on string host = 127.0.0.1 ; ushort port = 15937; // The Master Server communicates over TCP TCPMasterClient client = new TCPMasterClient(); // Just call the connect method and you are ready to go client.Connect(host, ort); (2) Once your server is accepted (which you can use the serverAccepted event) you can create your request to the master server. The request is a JSONNode object that follows this structure: { get: { id: myGame , type: any , mode: all } } You can do this with code similar to the following: // The overall game id to select from string gameId = myGame ; // The game type to choose from, if any then all types will be returned string gameType = any ; // The game mode to choose from, if all then all game modes will be returned string gameMode = all ; // Create the get request with the desired filters JSONNode sendData = JSONNode.Parse( {} ); JSONClass getData = new JSONClass(); // The id of the game to get getData.Add( id , gameId); getData.Add( type , gameType); getData.Add( mode , gameMode); sendData.Add( get , getData); (3) Now that we have the json sendData we need to send it to the server. Since JSON can be a string representation, you can send it directly to the server as a Text frame in Forge: // Send the request to the server client.Send(Frame.Text.CreateFromString(client.Time.Timestep, sendData.ToString(), true, Receivers.Server, MessageGroupIds.MASTER_SERVER_GET, true)); (4) If you listen to the textMessageReceived event on the client object you will be able to capture the response from the server. This response will contain any errors (if any) and most importantly, your game list! (5) Now that you have the JSON response from the server, you will need to parse it into the MasterServerResponse object. Lets imagine that your json response variable is called data , then the code you will need to parse the response to this object is: // Create a C# object for the response from the master server MasterServerResponse response = new MasterServerResponse(data[ hosts ].AsArray); Note : If data[\"hosts\"] is null, then there was an error. (6) Now that you have the MasterServerResponse object, you are ready to start writing your code for the UI and any other behaviors you want to execute based on the server listing. foreach (MasterServerResponse.Server server in response.serverResponse) { // TODO: Do something with the server information here! } Refresh Complete Sample Below is a complete example of how to: Connect to master server Request the games list from the master server Process the list of games returned from the master server Disconnect from the master server The below example can be used to refresh the current listings of hosts from the master server. Please be sure to read the comments within the code to better understand what is going on. It is also good to scroll up and reference the top of this page to see why and when things happen in this sample. public void Refresh() { // TODO: Clear out any previously listed servers // The Master Server communicates over TCP TCPMasterClient client = new TCPMasterClient(); // Once this client has been accepted by the master server it should sent it's get request client.serverAccepted += () = { try { // The overall game id to select from string gameId = myGame ; // The game type to choose from, if any then all types will be returned string gameType = any ; // The game mode to choose from, if all then all game modes will be returned string gameMode = all ; // Create the get request with the desired filters JSONNode sendData = JSONNode.Parse( {} ); JSONClass getData = new JSONClass(); // The id of the game to get getData.Add( id , gameId); getData.Add( type , gameType); getData.Add( mode , gameMode); sendData.Add( get , getData); // Send the request to the server client.Send(Frame.Text.CreateFromString(client.Time.Timestep, sendData.ToString(), true, Receivers.Server, MessageGroupIds.MASTER_SERVER_GET, true)); } catch { // If anything fails, then this client needs to be disconnected client.Disconnect(true); client = null; } }; // An event that is raised when the server responds with hosts client.textMessageReceived += (player, frame) = { try { // Get the list of hosts to iterate through from the frame payload JSONNode data = JSONNode.Parse(frame.ToString()); if (data[ hosts ] != null) { // Create a C# object for the response from the master server MasterServerResponse response = new MasterServerResponse(data[ hosts ].AsArray); if (response != null response.serverResponse.Count 0) { // Go through all of the available hosts and add them to the server browser foreach (MasterServerResponse.Server server in response.serverResponse) { Debug.Log( Name: + server.Name); Debug.Log( Address: + server.Address); Debug.Log( Port: + server.Port); Debug.Log( Comment: + server.Comment); Debug.Log( Type: + server.Type); Debug.Log( Mode: + server.Mode); Debug.Log( Players: + server.Players); Debug.Log( Max Players: + server.MaxPlayers); Debug.Log( Protocol: + server.Protocol); // TODO: Update UI or something with the above data } } } } finally { if (client != null) { // If we succeed or fail the client needs to disconnect from the Master Server client.Disconnect(true); client = null; } } }; client.Connect(masterServerHost, (ushort)masterServerPort); }","title":"Getting Host List From Master Server"},{"location":"MasterServer/getting-host-list/#getting-host-list-from-master-server","text":"If you have not already, we would suggest reviewing the Master Server Quick Start documentation to get familiar with the Master Server and to setup the stand alone executable and then reviewing Connecting to Master Server to learn how to register your game server on the master server.","title":"Getting Host List From Master Server"},{"location":"MasterServer/getting-host-list/#request-stages","text":"There are a few stages when requesting the list of servers from the master server: Connect to Master Server Create a JSONNode request Send the request to the server Get response from the server Parse response from server Implement your code (1) So the very first thing you have to do is to connect to the master server. We have created a helper class to get you doing this quickly: // TODO: This will be the address of the machine your master server is running on string host = 127.0.0.1 ; ushort port = 15937; // The Master Server communicates over TCP TCPMasterClient client = new TCPMasterClient(); // Just call the connect method and you are ready to go client.Connect(host, ort); (2) Once your server is accepted (which you can use the serverAccepted event) you can create your request to the master server. The request is a JSONNode object that follows this structure: { get: { id: myGame , type: any , mode: all } } You can do this with code similar to the following: // The overall game id to select from string gameId = myGame ; // The game type to choose from, if any then all types will be returned string gameType = any ; // The game mode to choose from, if all then all game modes will be returned string gameMode = all ; // Create the get request with the desired filters JSONNode sendData = JSONNode.Parse( {} ); JSONClass getData = new JSONClass(); // The id of the game to get getData.Add( id , gameId); getData.Add( type , gameType); getData.Add( mode , gameMode); sendData.Add( get , getData); (3) Now that we have the json sendData we need to send it to the server. Since JSON can be a string representation, you can send it directly to the server as a Text frame in Forge: // Send the request to the server client.Send(Frame.Text.CreateFromString(client.Time.Timestep, sendData.ToString(), true, Receivers.Server, MessageGroupIds.MASTER_SERVER_GET, true)); (4) If you listen to the textMessageReceived event on the client object you will be able to capture the response from the server. This response will contain any errors (if any) and most importantly, your game list! (5) Now that you have the JSON response from the server, you will need to parse it into the MasterServerResponse object. Lets imagine that your json response variable is called data , then the code you will need to parse the response to this object is: // Create a C# object for the response from the master server MasterServerResponse response = new MasterServerResponse(data[ hosts ].AsArray); Note : If data[\"hosts\"] is null, then there was an error. (6) Now that you have the MasterServerResponse object, you are ready to start writing your code for the UI and any other behaviors you want to execute based on the server listing. foreach (MasterServerResponse.Server server in response.serverResponse) { // TODO: Do something with the server information here! }","title":"Request stages"},{"location":"MasterServer/getting-host-list/#refresh-complete-sample","text":"Below is a complete example of how to: Connect to master server Request the games list from the master server Process the list of games returned from the master server Disconnect from the master server The below example can be used to refresh the current listings of hosts from the master server. Please be sure to read the comments within the code to better understand what is going on. It is also good to scroll up and reference the top of this page to see why and when things happen in this sample. public void Refresh() { // TODO: Clear out any previously listed servers // The Master Server communicates over TCP TCPMasterClient client = new TCPMasterClient(); // Once this client has been accepted by the master server it should sent it's get request client.serverAccepted += () = { try { // The overall game id to select from string gameId = myGame ; // The game type to choose from, if any then all types will be returned string gameType = any ; // The game mode to choose from, if all then all game modes will be returned string gameMode = all ; // Create the get request with the desired filters JSONNode sendData = JSONNode.Parse( {} ); JSONClass getData = new JSONClass(); // The id of the game to get getData.Add( id , gameId); getData.Add( type , gameType); getData.Add( mode , gameMode); sendData.Add( get , getData); // Send the request to the server client.Send(Frame.Text.CreateFromString(client.Time.Timestep, sendData.ToString(), true, Receivers.Server, MessageGroupIds.MASTER_SERVER_GET, true)); } catch { // If anything fails, then this client needs to be disconnected client.Disconnect(true); client = null; } }; // An event that is raised when the server responds with hosts client.textMessageReceived += (player, frame) = { try { // Get the list of hosts to iterate through from the frame payload JSONNode data = JSONNode.Parse(frame.ToString()); if (data[ hosts ] != null) { // Create a C# object for the response from the master server MasterServerResponse response = new MasterServerResponse(data[ hosts ].AsArray); if (response != null response.serverResponse.Count 0) { // Go through all of the available hosts and add them to the server browser foreach (MasterServerResponse.Server server in response.serverResponse) { Debug.Log( Name: + server.Name); Debug.Log( Address: + server.Address); Debug.Log( Port: + server.Port); Debug.Log( Comment: + server.Comment); Debug.Log( Type: + server.Type); Debug.Log( Mode: + server.Mode); Debug.Log( Players: + server.Players); Debug.Log( Max Players: + server.MaxPlayers); Debug.Log( Protocol: + server.Protocol); // TODO: Update UI or something with the above data } } } } finally { if (client != null) { // If we succeed or fail the client needs to disconnect from the Master Server client.Disconnect(true); client = null; } } }; client.Connect(masterServerHost, (ushort)masterServerPort); }","title":"Refresh Complete Sample"},{"location":"MasterServer/quick-start/","text":"Master Server Quick Start The Master Server is a stand alone server that allows for games to be publicly (or privately with password) listed for the world to join. If you've ever played an online game with friends, chances are that you have had to get their IP address in order to join their hosted games. The Master Server gives your game the ability to have these fancy server listings. Getting the Master Server The Master Server can either be built from source in the project repo, or downloaded from the nightly builds . Running the Master Server Upon downloading this file (a .zip file) you will find that within the contents is a README file to get you started and the .exe file to be run. Windows In windows it is very simple to host a Master Server. Just double click the MasterServer.exe and you are up and running! Other Platforms On any platform other than Windows, as you may know, you can not run an .exe file. However with the power of Mono you will be abel to do such things without any extra coding needed. Please follow the instructions required to install mono onto your respective platform. After this you can open up a terminal window in the location where the .exe file was extracted and you can run the program by doing mono MasterServer.exe . Firewall So in order for your MasterServer to be effective, you will need to allow the process through your machine firewall (see instructions on how to allow a process on your operating system through the firewall). Once you have allowed the process on your machine through your machine's firewall, it is time for you to allow the port to your machine on the network. Yes, there are technically 2 firewalls that you have to setup to allow an application to be visible to the outside world. Every router is different and so there are many different ways to allow port forwarding to your machine. Please view an online guide on how to set this up for your router make/model. The default port number for the master server is 15940 . Using the Master Server So now that we have the master server up and running on our machine, it is time to give it a test and see what all is needed to use it. Lets begin by making sure that everything is working properly by running the built in testing method for Master Servers that come with Forge Networking. Open your project with Forge Networking Open the demo Multiplayer Menu scene Make sure your build settings have a scene after the Multiplayer Menu scene in it Locate the Canvas game object in the hierarchy and select it Locate the Master Server Host and Master Server Port in the Inspector Input the local or static IP address of the machine your Master Server is running on Input 15940 as the port number for the Master Server Click the play button in Unity Click this Host button to start a game server If you look at the Master Server command/terminal you should notice that a message appears with your game servers IP address and port number saying that it has been registered. At this point any clients can now connect to your Master Server and get the host listings. If the message did not appear then you've probably not setup the firewall settings correctly on either your machine or your router/network.","title":"Master Server Quick Start"},{"location":"MasterServer/quick-start/#master-server-quick-start","text":"The Master Server is a stand alone server that allows for games to be publicly (or privately with password) listed for the world to join. If you've ever played an online game with friends, chances are that you have had to get their IP address in order to join their hosted games. The Master Server gives your game the ability to have these fancy server listings.","title":"Master Server Quick Start"},{"location":"MasterServer/quick-start/#getting-the-master-server","text":"The Master Server can either be built from source in the project repo, or downloaded from the nightly builds .","title":"Getting the Master Server"},{"location":"MasterServer/quick-start/#running-the-master-server","text":"Upon downloading this file (a .zip file) you will find that within the contents is a README file to get you started and the .exe file to be run.","title":"Running the Master Server"},{"location":"MasterServer/quick-start/#windows","text":"In windows it is very simple to host a Master Server. Just double click the MasterServer.exe and you are up and running!","title":"Windows"},{"location":"MasterServer/quick-start/#other-platforms","text":"On any platform other than Windows, as you may know, you can not run an .exe file. However with the power of Mono you will be abel to do such things without any extra coding needed. Please follow the instructions required to install mono onto your respective platform. After this you can open up a terminal window in the location where the .exe file was extracted and you can run the program by doing mono MasterServer.exe .","title":"Other Platforms"},{"location":"MasterServer/quick-start/#firewall","text":"So in order for your MasterServer to be effective, you will need to allow the process through your machine firewall (see instructions on how to allow a process on your operating system through the firewall). Once you have allowed the process on your machine through your machine's firewall, it is time for you to allow the port to your machine on the network. Yes, there are technically 2 firewalls that you have to setup to allow an application to be visible to the outside world. Every router is different and so there are many different ways to allow port forwarding to your machine. Please view an online guide on how to set this up for your router make/model. The default port number for the master server is 15940 .","title":"Firewall"},{"location":"MasterServer/quick-start/#using-the-master-server","text":"So now that we have the master server up and running on our machine, it is time to give it a test and see what all is needed to use it. Lets begin by making sure that everything is working properly by running the built in testing method for Master Servers that come with Forge Networking. Open your project with Forge Networking Open the demo Multiplayer Menu scene Make sure your build settings have a scene after the Multiplayer Menu scene in it Locate the Canvas game object in the hierarchy and select it Locate the Master Server Host and Master Server Port in the Inspector Input the local or static IP address of the machine your Master Server is running on Input 15940 as the port number for the Master Server Click the play button in Unity Click this Host button to start a game server If you look at the Master Server command/terminal you should notice that a message appears with your game servers IP address and port number saying that it has been registered. At this point any clients can now connect to your Master Server and get the host listings. If the message did not appear then you've probably not setup the firewall settings correctly on either your machine or your router/network.","title":"Using the Master Server"},{"location":"MasterServer/windows-server-firewall-setup/","text":"Windows Server Firewall Setup Sometimes images speak louder than words, so we've compiled a list of images to show you exactly what you need to do in order to allow the Master Server to work on your Windows Server either in your home or in the cloud! First you need to open your **Advanced Firewall Settings\" Next you need to select Inbound Rules then select New Rule... Next you will need to select Port and then click Next Next, make sure that TCP is selected and that you enter the correct port number for your Master Server. The default port is 15940 . Then click Next Next you need to select Allow the connection . Click Next After that, just keep all the checkboxes at default (checked). Click Next Lastly give it a good name that is easy to find and click Finish Done That is it, you should be ready to go. If you experience any other issues, make sure that your network firewall is allowing the connection to this machine and allowing the specified port number.","title":"Windows Server Firewall Setup"},{"location":"MasterServer/windows-server-firewall-setup/#windows-server-firewall-setup","text":"Sometimes images speak louder than words, so we've compiled a list of images to show you exactly what you need to do in order to allow the Master Server to work on your Windows Server either in your home or in the cloud! First you need to open your **Advanced Firewall Settings\" Next you need to select Inbound Rules then select New Rule... Next you will need to select Port and then click Next Next, make sure that TCP is selected and that you enter the correct port number for your Master Server. The default port is 15940 . Then click Next Next you need to select Allow the connection . Click Next After that, just keep all the checkboxes at default (checked). Click Next Lastly give it a good name that is easy to find and click Finish","title":"Windows Server Firewall Setup"},{"location":"MasterServer/windows-server-firewall-setup/#done","text":"That is it, you should be ready to go. If you experience any other issues, make sure that your network firewall is allowing the connection to this machine and allowing the specified port number.","title":"Done"},{"location":"NetWorker/temporarily-blocking-connections/","text":"Temporarily Blocking Connections Sometimes, when a match starts, you don't want people being able to join the server, even when other players leave. You are able to tell the server to no longer accept connections as seen below: NetWorker server = new UdpServer(32); server.Connect(); // ... // Don't allow any more connections to this server, but don't kick any current connections ((IServer)server).StopAcceptingConnections(); Obviously we needed to give you a way to be able to start accepting connections again otherwise that would be kinda rude. So we wen't ahead and made the following function for you to begin accepting connections again. Note that this is a continuation of the above example // Start allowing for connections to this server again ((IServer)server).StartAcceptingConnections(); Lastly, you may have forgotten or don't know if you stopped allowing connections, so we made this handy boolean for you to check against! Note that this is a continuation of the above example if (!((IServer)server).AcceptingConnections) { // Connections are currently not allowed for this server }","title":"Temporarily Blocking Connections"},{"location":"NetWorker/temporarily-blocking-connections/#temporarily-blocking-connections","text":"Sometimes, when a match starts, you don't want people being able to join the server, even when other players leave. You are able to tell the server to no longer accept connections as seen below: NetWorker server = new UdpServer(32); server.Connect(); // ... // Don't allow any more connections to this server, but don't kick any current connections ((IServer)server).StopAcceptingConnections(); Obviously we needed to give you a way to be able to start accepting connections again otherwise that would be kinda rude. So we wen't ahead and made the following function for you to begin accepting connections again. Note that this is a continuation of the above example // Start allowing for connections to this server again ((IServer)server).StartAcceptingConnections(); Lastly, you may have forgotten or don't know if you stopped allowing connections, so we made this handy boolean for you to check against! Note that this is a continuation of the above example if (!((IServer)server).AcceptingConnections) { // Connections are currently not allowed for this server }","title":"Temporarily Blocking Connections"},{"location":"NetWorker/thread-safe-player-iteration/","text":"Thread Safe Player Iteration Sometimes it is important for our server to go through every player on the network and perform some action for them. Being that the players can connect asynchronously to the server, the Players list can be altered at any point, even while we are currently iterating through the players. There are two ways to be able to go through the players in a thread-safe manor WHICH YOU MUST ALWAYS DO . You either will be required to lock the players before performing any actions on them, or you can use the provided helper method NetWorker::IteratePlayers . If you were to use a simple lock, then let's say we had a reference to a NetWorker with the variable name myNetWorker . Now you have direct access to the players via the myNetWorker.Players getter, however it is not thread safe to just simply access them in this way; you instead will lock them as seen in the following: Locking lock (myNetWorker.Players) { // Do your player iteration logic here } The second way would be to use the NetWorker::IteratePlayers method as described above. There are two ways that you can do this, the first being to provide a lambda expression for quick inline actions and the other is to provide a function pointer. Lambda Expression // This is an example of using a lambda expression myNetWorker.IteratePlayers((player) = { // Do your player iteration logic here }); Function Pointer // This is an example of using a function pointer myNetWorker.IteratePlayers(GoThroughPlayers); // ... private void GoThroughPlayers(NetworkingPlayer player) { // Do your player iteration logic here }","title":"Thread Safe Player Iteration"},{"location":"NetWorker/thread-safe-player-iteration/#thread-safe-player-iteration","text":"Sometimes it is important for our server to go through every player on the network and perform some action for them. Being that the players can connect asynchronously to the server, the Players list can be altered at any point, even while we are currently iterating through the players. There are two ways to be able to go through the players in a thread-safe manor WHICH YOU MUST ALWAYS DO . You either will be required to lock the players before performing any actions on them, or you can use the provided helper method NetWorker::IteratePlayers . If you were to use a simple lock, then let's say we had a reference to a NetWorker with the variable name myNetWorker . Now you have direct access to the players via the myNetWorker.Players getter, however it is not thread safe to just simply access them in this way; you instead will lock them as seen in the following:","title":"Thread Safe Player Iteration"},{"location":"NetWorker/thread-safe-player-iteration/#locking","text":"lock (myNetWorker.Players) { // Do your player iteration logic here } The second way would be to use the NetWorker::IteratePlayers method as described above. There are two ways that you can do this, the first being to provide a lambda expression for quick inline actions and the other is to provide a function pointer.","title":"Locking"},{"location":"NetWorker/thread-safe-player-iteration/#lambda-expression","text":"// This is an example of using a lambda expression myNetWorker.IteratePlayers((player) = { // Do your player iteration logic here });","title":"Lambda Expression"},{"location":"NetWorker/thread-safe-player-iteration/#function-pointer","text":"// This is an example of using a function pointer myNetWorker.IteratePlayers(GoThroughPlayers); // ... private void GoThroughPlayers(NetworkingPlayer player) { // Do your player iteration logic here }","title":"Function Pointer"},{"location":"NetworkContractWizard/extending-generated-classes/","text":"Extending Generated Classes You may have noticed by now that Forge Networking Remastered (FNR) will generate network code through the Network Contract Wizard (NCW) . The main purpose of this is to completely remove reflection and make the system easier to test and debug. The generated code will hook into the Forge Networking core framework and setup hooks and connections so that you, as the user of the API, does not have to do all that repetitive work and you can just focus on developing your product. If you have looked through the generated code you may have seen that the classes that are generated are partial classes. If you are unfamiliar with partial classes, we would like to invite you to review the standard MSDN C# documentation for partial classes . If you are familiar with the concept of partial classes then you are already a step closer to being able to easily extend the generated code. In many cases it would be advantageous for us to be able to add more code to generated code. This is because we may have multiple different objects inheriting or using the classes that are generated. In this scenario, it would not make sense to write another class and make sure to remember to attach it to every object that uses the class in question. There are scenarios where you would just like to be able to manually add more options to a generated class for further use or for utility sake. To do this, all you need to do is create a new class with the same name as the target class in question. Then make sure to place the keyword partial just before you type the class keyword. public partial class MyClass //\u2026 Partial classes are essentially compiled together into one combined class, so it is like editing the source file without having to actually change the source file.","title":"Extending Generated Classes"},{"location":"NetworkContractWizard/extending-generated-classes/#extending-generated-classes","text":"You may have noticed by now that Forge Networking Remastered (FNR) will generate network code through the Network Contract Wizard (NCW) . The main purpose of this is to completely remove reflection and make the system easier to test and debug. The generated code will hook into the Forge Networking core framework and setup hooks and connections so that you, as the user of the API, does not have to do all that repetitive work and you can just focus on developing your product. If you have looked through the generated code you may have seen that the classes that are generated are partial classes. If you are unfamiliar with partial classes, we would like to invite you to review the standard MSDN C# documentation for partial classes . If you are familiar with the concept of partial classes then you are already a step closer to being able to easily extend the generated code. In many cases it would be advantageous for us to be able to add more code to generated code. This is because we may have multiple different objects inheriting or using the classes that are generated. In this scenario, it would not make sense to write another class and make sure to remember to attach it to every object that uses the class in question. There are scenarios where you would just like to be able to manually add more options to a generated class for further use or for utility sake. To do this, all you need to do is create a new class with the same name as the target class in question. Then make sure to place the keyword partial just before you type the class keyword. public partial class MyClass //\u2026 Partial classes are essentially compiled together into one combined class, so it is like editing the source file without having to actually change the source file.","title":"Extending Generated Classes"},{"location":"NetworkContractWizard/name-collision-issues/","text":"Name Collision Issues As you may have read in Network Object, the network object has an owner. This owner is responsible for updating the Fields. Since there is one owner of an object, you may want to update who owns an object at runtime. For example, if there is a car on the street, it may be currently owned by the server (because the server spawned the object), however a player gets into the car to drive it, now we would want the player to own the car and update it's variables. To do this we have two methods that are a part of the Network Object and one extra method to override to validate ownership changes on the server.","title":"Name Collision Issues"},{"location":"NetworkContractWizard/name-collision-issues/#name-collision-issues","text":"As you may have read in Network Object, the network object has an owner. This owner is responsible for updating the Fields. Since there is one owner of an object, you may want to update who owns an object at runtime. For example, if there is a car on the street, it may be currently owned by the server (because the server spawned the object), however a player gets into the car to drive it, now we would want the player to own the car and update it's variables. To do this we have two methods that are a part of the Network Object and one extra method to override to validate ownership changes on the server.","title":"Name Collision Issues"},{"location":"NetworkContractWizard/network-contract-wizard-ncw/","text":"Network Contract Wizard (NCW) The Network Contract Wizard is the new way for you to implement networking for your game/app. To do so you will need to go to Window- Forge Networking- Network Contract Wizard as shown in the example below. After opening the window you will be presented with this. 1)Toggle lighting on/off for the editor window only. This will make it easier for your eyes depending on what lighting situation you have. 2)Create, this will make networked objects for you to use for your game/app. (You will spend most of your time hitting this beautifully designed button). 3)Deletion, this will properly delete the networked objects that you have made. Note: You are able to tap any of the NetworkObjects to modify them as well. Creation Menu 1)Name field for you to name your networked object (Do not use the same name as ones already made) 2)Add fields (This is where you would add variables to sync across the network) 3)Add RPC (This is where you would create callbacks for other clients to messages/data being sent) Adding a Field 1)The name of the variable 2)The type of variable this will be 3)There are many different types to select from (This is just an example of selecting int for this variable) Note: The trash bin next to this variable will delete it. Adding an RPC 1)Name of the RPC 2)Arguments for this RPC that will be sent across the network. 3)Value type that can be passed across the network. 4)Deletion of this RPC 5)Deletion of this Value Type 6)Add more Value Types for the arguments Main Menu Deletion 1)This will trash this Networked Object correctly. 2)You will be prompted with this window when doing so. Project Directory You will notice that all generated code will be located in your project directory under Generated . Note: This will be changeable from the editor in the future. Note: if you are getting RPCs lagging, then being called all at once, make sure \"autoconnect profiler\" is turned off in your build settings.","title":"Network Contract Wizard (NCW)"},{"location":"NetworkContractWizard/network-contract-wizard-ncw/#network-contract-wizard-ncw","text":"The Network Contract Wizard is the new way for you to implement networking for your game/app. To do so you will need to go to Window- Forge Networking- Network Contract Wizard as shown in the example below. After opening the window you will be presented with this. 1)Toggle lighting on/off for the editor window only. This will make it easier for your eyes depending on what lighting situation you have. 2)Create, this will make networked objects for you to use for your game/app. (You will spend most of your time hitting this beautifully designed button). 3)Deletion, this will properly delete the networked objects that you have made. Note: You are able to tap any of the NetworkObjects to modify them as well. Creation Menu 1)Name field for you to name your networked object (Do not use the same name as ones already made) 2)Add fields (This is where you would add variables to sync across the network) 3)Add RPC (This is where you would create callbacks for other clients to messages/data being sent) Adding a Field 1)The name of the variable 2)The type of variable this will be 3)There are many different types to select from (This is just an example of selecting int for this variable) Note: The trash bin next to this variable will delete it. Adding an RPC 1)Name of the RPC 2)Arguments for this RPC that will be sent across the network. 3)Value type that can be passed across the network. 4)Deletion of this RPC 5)Deletion of this Value Type 6)Add more Value Types for the arguments Main Menu Deletion 1)This will trash this Networked Object correctly. 2)You will be prompted with this window when doing so. Project Directory You will notice that all generated code will be located in your project directory under Generated . Note: This will be changeable from the editor in the future. Note: if you are getting RPCs lagging, then being called all at once, make sure \"autoconnect profiler\" is turned off in your build settings.","title":"Network Contract Wizard (NCW)"},{"location":"NetworkObject/changing-ownership/","text":"Changing Ownership There are two different methods to use for changing ownership of an object; one for the client and one for the server. The client method is TakeOwnership and has no arguments. Any client can call this method on the networkObject to request ownership of an object. The method that you would use to force ownership from the server is AssignOwnership which has an argument NetworkingPlayer (the player who is going to be the new owner for the network object). Only the server can call this method on the networkObject due to it's authoritative nature. If a client were to call this method, nothing would happen. As for verifying an ownership change request, which if you don't do it will just accept the change ownership request, there is one method to override. We live in a world where we just can't trust our clients to send us messages that they should be in the way that we wish them to. Clients may want to cheat the system and try to exploit the network for fun or just so that they can win. Because of this we have created a simple method for you to override in order to check any game critical RPCs that are received from the client and verify them. Before continuing with this part of the documentation, please review the Extending Generated Classes documentation to learn more about partial classes. When we use the Network Contract Wizard (NCW), it will create 2 generated classes; one for our MonoBehaviour and one for our NetworkObject. The one that we want to focus on in this example is the generated NetworkObject . So let's say that we opened up the Network Contract Wizard (NCW) and we created a contract named Car ; this will generate a NetworkObject class named CarNetworkObject . Now in another folder (not in the Generated folder) you will create a new C# script called CarNetworkObject . In here you will create your partial class for the CarNetworkObject and you will override the AllowOwnershipChange method like so: AllowOwnershipChange protected override bool AllowOwnershipChange(NetworkingPlayer newOwner) { // The newOwner is the NetworkingPlayer that is requesting the ownership change, you can get the current owner with just Owner } Notice that you need to return a boolean from this function. If you return true then the ownership change will be allowed to go through, it will be invoked on the server and on the clients. If you return false then the ownership change will not be invoked at all and will be dropped.","title":"Changing Ownership"},{"location":"NetworkObject/changing-ownership/#changing-ownership","text":"There are two different methods to use for changing ownership of an object; one for the client and one for the server. The client method is TakeOwnership and has no arguments. Any client can call this method on the networkObject to request ownership of an object. The method that you would use to force ownership from the server is AssignOwnership which has an argument NetworkingPlayer (the player who is going to be the new owner for the network object). Only the server can call this method on the networkObject due to it's authoritative nature. If a client were to call this method, nothing would happen. As for verifying an ownership change request, which if you don't do it will just accept the change ownership request, there is one method to override. We live in a world where we just can't trust our clients to send us messages that they should be in the way that we wish them to. Clients may want to cheat the system and try to exploit the network for fun or just so that they can win. Because of this we have created a simple method for you to override in order to check any game critical RPCs that are received from the client and verify them. Before continuing with this part of the documentation, please review the Extending Generated Classes documentation to learn more about partial classes. When we use the Network Contract Wizard (NCW), it will create 2 generated classes; one for our MonoBehaviour and one for our NetworkObject. The one that we want to focus on in this example is the generated NetworkObject . So let's say that we opened up the Network Contract Wizard (NCW) and we created a contract named Car ; this will generate a NetworkObject class named CarNetworkObject . Now in another folder (not in the Generated folder) you will create a new C# script called CarNetworkObject . In here you will create your partial class for the CarNetworkObject and you will override the AllowOwnershipChange method like so:","title":"Changing Ownership"},{"location":"NetworkObject/changing-ownership/#allowownershipchange","text":"protected override bool AllowOwnershipChange(NetworkingPlayer newOwner) { // The newOwner is the NetworkingPlayer that is requesting the ownership change, you can get the current owner with just Owner } Notice that you need to return a boolean from this function. If you return true then the ownership change will be allowed to go through, it will be invoked on the server and on the clients. If you return false then the ownership change will not be invoked at all and will be dropped.","title":"AllowOwnershipChange"},{"location":"NetworkObject/destroying-the-network-object/","text":"Destroying the Network Object One of the most common actions that you may want to do on the network is to destroy the various network objects that you create. Any object that has a networkObject or that derives from one of the generated classes made by the Network Contract Wizard (NCW) can be destroyed on the network. If you have a reference to the object you wish to destroy then it is just a matter of calling one function: networkObject.Destroy(); This will not only destroy the Network Object, but it will also call the UnityEngine.GameObject::Destroy method on the gameObject that the networkObject is attached to. If you wish to know when an object is destroyed you can register to the NetworkObject::onDestroy event. networkObject.onDestroy += MyMethod;","title":"Destroying the Network Object"},{"location":"NetworkObject/destroying-the-network-object/#destroying-the-network-object","text":"One of the most common actions that you may want to do on the network is to destroy the various network objects that you create. Any object that has a networkObject or that derives from one of the generated classes made by the Network Contract Wizard (NCW) can be destroyed on the network. If you have a reference to the object you wish to destroy then it is just a matter of calling one function: networkObject.Destroy(); This will not only destroy the Network Object, but it will also call the UnityEngine.GameObject::Destroy method on the gameObject that the networkObject is attached to. If you wish to know when an object is destroyed you can register to the NetworkObject::onDestroy event. networkObject.onDestroy += MyMethod;","title":"Destroying the Network Object"},{"location":"NetworkObject/fields/","text":"Fields The Network Object (most commonly seen as Network Object) is a variable found in the classes that were generated from using the Network Contract Wizard (NCW). When you create a field in the Network Contract Wizard (NCW) for a generated type, then it will be added as a property of that generated type. Below are the currently supported types of fields allowed in a network object field. Field Size byte 8 bits sbyte 8 bits short 16 bits ushort 16 bits int 32 bits uint 32 bits long 64 bits ulong 64 bits float 32 bits double 64 bits char 8 bits string 32 bits + length * 8 Vector 96 bits Vector2 64 bits Vector3 96 bits Vector4 128 bits Quaternion 128 bits Color 128 bits Field Usage When you generate a class it will be generated with a networkObject variable. This variable has all of the fields that you described in the Network Contract Wizard (NCW) built into it. For example, if you created a field in the Network Contract Wizard (NCW) that was named position and was selected to be a VECTOR3 then you will have access to it by doing networkObject.position . One thing that you will notice when doing this is that this field is actually a C# property, but we will explain this momentarily. On some fields (such as VECTOR3) you will notice that it has a greyed out button labeled interpolate. If you were to click this, it will turn on interpolation for this field. You can set the interpolation time by assigning the text input field to the right of the button once it is active, default is 0.15. If you are not familiar with interpolation, basically when we send messages across the network we are dealing with millisecond gaps of information, this will cause objects to seem as though they were teleporting or lagging. By using interpolation, you can smooth out these movements to look more natural. Behind the Scenes What is going on behind the scenes? Well let's start with where we left off in the last section on how the fields are actually properties. These properties have a getter/setter on each one. The getter will simply return a private field in the generated network object class; however, the setter does a few more actions. When you assign the value of the property, the setter will first set the private field to the value specified. Next a dirty flag will be set to tell the network to syndicate the change for that variable on the next network update for this object. What this dirty flag allows is for FNR to be able to only pick fields that have changed and send those across the network. This reduces the amount of data being sent by a lot depending on how often other variables are updated.","title":"Fields"},{"location":"NetworkObject/fields/#fields","text":"The Network Object (most commonly seen as Network Object) is a variable found in the classes that were generated from using the Network Contract Wizard (NCW). When you create a field in the Network Contract Wizard (NCW) for a generated type, then it will be added as a property of that generated type. Below are the currently supported types of fields allowed in a network object field. Field Size byte 8 bits sbyte 8 bits short 16 bits ushort 16 bits int 32 bits uint 32 bits long 64 bits ulong 64 bits float 32 bits double 64 bits char 8 bits string 32 bits + length * 8 Vector 96 bits Vector2 64 bits Vector3 96 bits Vector4 128 bits Quaternion 128 bits Color 128 bits","title":"Fields"},{"location":"NetworkObject/fields/#field-usage","text":"When you generate a class it will be generated with a networkObject variable. This variable has all of the fields that you described in the Network Contract Wizard (NCW) built into it. For example, if you created a field in the Network Contract Wizard (NCW) that was named position and was selected to be a VECTOR3 then you will have access to it by doing networkObject.position . One thing that you will notice when doing this is that this field is actually a C# property, but we will explain this momentarily. On some fields (such as VECTOR3) you will notice that it has a greyed out button labeled interpolate. If you were to click this, it will turn on interpolation for this field. You can set the interpolation time by assigning the text input field to the right of the button once it is active, default is 0.15. If you are not familiar with interpolation, basically when we send messages across the network we are dealing with millisecond gaps of information, this will cause objects to seem as though they were teleporting or lagging. By using interpolation, you can smooth out these movements to look more natural.","title":"Field Usage"},{"location":"NetworkObject/fields/#behind-the-scenes","text":"What is going on behind the scenes? Well let's start with where we left off in the last section on how the fields are actually properties. These properties have a getter/setter on each one. The getter will simply return a private field in the generated network object class; however, the setter does a few more actions. When you assign the value of the property, the setter will first set the private field to the value specified. Next a dirty flag will be set to tell the network to syndicate the change for that variable on the next network update for this object. What this dirty flag allows is for FNR to be able to only pick fields that have changed and send those across the network. This reduces the amount of data being sent by a lot depending on how often other variables are updated.","title":"Behind the Scenes"},{"location":"NetworkObject/RemoteProcedureCalls/buffered-rpcs/","text":"Buffered RPCs So you've probably gone through the Basic RPC Example by now and are curious about the various Receivers are that you could add when calling an RPC. If you browsed through the available Receivers you would have noticed ones suffixed with the word Buffered . For example AllBuffered or OthersBuffered . Buffering of RPC calls is important for players who are going to be joining the game late. For example let us say that you blew up a barrel at some point in the game. Now imagine someone coming into the game for the first time well after you blew up the barrel. How is that player going to know that the barrel is blown up so that they can't blow it up again? One solution you may try is using Buffered RPCs woo! What happens with buffered RPCs is that the RPC is stored on the server. The moment that a player has been accepted they will first receive all of the currently active network objects. Once the player has confirmed that they have received the network objects then the server will send down the buffered RPCs. Effectively calling the explode barrel RPC that was called a long time ago. Now of course this is a bad example of something to do gameplay-wise because then the player who just joined would have a bunch of barrels exploding out of nowhere, but you should be able to understand the purpose of buffered RPCs now. So to buffer an RPC all you have to do is select a Receivers which has a Buffered suffix as seen below: float explosionVelocity = 99.98f; networkObject.SendRpc(RPC_BLOWUP_BARREL, Receivers.AllBuffered, explosionVelocity);","title":"Buffered RPCs"},{"location":"NetworkObject/RemoteProcedureCalls/buffered-rpcs/#buffered-rpcs","text":"So you've probably gone through the Basic RPC Example by now and are curious about the various Receivers are that you could add when calling an RPC. If you browsed through the available Receivers you would have noticed ones suffixed with the word Buffered . For example AllBuffered or OthersBuffered . Buffering of RPC calls is important for players who are going to be joining the game late. For example let us say that you blew up a barrel at some point in the game. Now imagine someone coming into the game for the first time well after you blew up the barrel. How is that player going to know that the barrel is blown up so that they can't blow it up again? One solution you may try is using Buffered RPCs woo! What happens with buffered RPCs is that the RPC is stored on the server. The moment that a player has been accepted they will first receive all of the currently active network objects. Once the player has confirmed that they have received the network objects then the server will send down the buffered RPCs. Effectively calling the explode barrel RPC that was called a long time ago. Now of course this is a bad example of something to do gameplay-wise because then the player who just joined would have a bunch of barrels exploding out of nowhere, but you should be able to understand the purpose of buffered RPCs now. So to buffer an RPC all you have to do is select a Receivers which has a Buffered suffix as seen below: float explosionVelocity = 99.98f; networkObject.SendRpc(RPC_BLOWUP_BARREL, Receivers.AllBuffered, explosionVelocity);","title":"Buffered RPCs"},{"location":"NetworkObject/RemoteProcedureCalls/clearing-buffered-rpcs/","text":"Clearing Buffered RPCs When buffering RPC calls, you may have noticed that the buffered call exists for the entire life-span of the network object. This is so that critical functions can be performed on an object to clients who connect later (after the RPC was executed). The problem you may run into with this is that you would need to delete the object to reset the level or partly reset the level. This of course presents the problem of managing and instantiating objects remotely. To resolve this issue, you can clear out the buffered RPCs of an object using the NetworkObject::ClearRpcBuffer . This will request for the buffered RPCs of a specific object to be cleared on the server if called from the client, otherwise it will immediately clear the buffered RPCs for the network object in question if called from the server.","title":"Clearing Buffered RPCs"},{"location":"NetworkObject/RemoteProcedureCalls/clearing-buffered-rpcs/#clearing-buffered-rpcs","text":"When buffering RPC calls, you may have noticed that the buffered call exists for the entire life-span of the network object. This is so that critical functions can be performed on an object to clients who connect later (after the RPC was executed). The problem you may run into with this is that you would need to delete the object to reset the level or partly reset the level. This of course presents the problem of managing and instantiating objects remotely. To resolve this issue, you can clear out the buffered RPCs of an object using the NetworkObject::ClearRpcBuffer . This will request for the buffered RPCs of a specific object to be cleared on the server if called from the client, otherwise it will immediately clear the buffered RPCs for the network object in question if called from the server.","title":"Clearing Buffered RPCs"},{"location":"NetworkObject/RemoteProcedureCalls/remote-procedure-calls/","text":"Remote Procedure Calls Remote procedure calls (RPC) is a way to call functions over the network. So lets imagine that you ( ClientA ) had a method named \"Explode\" and I ( ClientB ) wanted to call that \"Explode\" method on your machine so that we both see the fireworks at the same time. Your main question might be: \"Well how can I call that function so that we both can see the fireworks explode at the same time?\" The answer of course is by doing a Remote Procedure call. An RPC can be called on a specific client, all clients, buffered clients, etc. RPCs use a reliable protocol - They always come in the right order and reception of RPCs is confirmed. To get you quickly started, check out the Basic RPC Example . Once you have gone through that example and consumed all of its educational value, feel free to brows the below links for more information. Buffered RPCs Sending RPC To Single Player RpcArgs and RpcInfo Structs RPC Validation by Server Replacing Previous Buffered RPCs Clearing Buffered RPCs","title":"Remote Procedure Calls"},{"location":"NetworkObject/RemoteProcedureCalls/remote-procedure-calls/#remote-procedure-calls","text":"Remote procedure calls (RPC) is a way to call functions over the network. So lets imagine that you ( ClientA ) had a method named \"Explode\" and I ( ClientB ) wanted to call that \"Explode\" method on your machine so that we both see the fireworks at the same time. Your main question might be: \"Well how can I call that function so that we both can see the fireworks explode at the same time?\" The answer of course is by doing a Remote Procedure call. An RPC can be called on a specific client, all clients, buffered clients, etc. RPCs use a reliable protocol - They always come in the right order and reception of RPCs is confirmed. To get you quickly started, check out the Basic RPC Example . Once you have gone through that example and consumed all of its educational value, feel free to brows the below links for more information. Buffered RPCs Sending RPC To Single Player RpcArgs and RpcInfo Structs RPC Validation by Server Replacing Previous Buffered RPCs Clearing Buffered RPCs","title":"Remote Procedure Calls"},{"location":"NetworkObject/RemoteProcedureCalls/replacing-previous-buffered-rpcs/","text":"Replacing Previous Buffered RPCs There are times where the buffered data that you want to send to new players that connect needs to be updated. Let's say that you were sending the current color of the winning team to a connecting player. Though you could run this on playerAccepted you might choose to do this with a buffered RPC. Unfortunately the currently winning team may change and so the color would need to be buffered yet again. If you were to keep buffering the team color you may end up with a buffer of 50 RPCs, so all 50 would get sent in order to the connecting player. Instead you can choose to replace the last call to a buffered RPC which will remove the last RPC called on this specific game object with the given RPC string name with the one you are currently executing. This is done easily by passing true to the SendRpc method overload that has the replacePrevious argument: bool replacePrevious = true; networkObject.SendRpc(RPC_MY_RPC_NAME, replacePrevious, Receivers.AllBuffered, new object[] { args go here });","title":"Replacing Previous Buffered RPCs"},{"location":"NetworkObject/RemoteProcedureCalls/replacing-previous-buffered-rpcs/#replacing-previous-buffered-rpcs","text":"There are times where the buffered data that you want to send to new players that connect needs to be updated. Let's say that you were sending the current color of the winning team to a connecting player. Though you could run this on playerAccepted you might choose to do this with a buffered RPC. Unfortunately the currently winning team may change and so the color would need to be buffered yet again. If you were to keep buffering the team color you may end up with a buffer of 50 RPCs, so all 50 would get sent in order to the connecting player. Instead you can choose to replace the last call to a buffered RPC which will remove the last RPC called on this specific game object with the given RPC string name with the one you are currently executing. This is done easily by passing true to the SendRpc method overload that has the replacePrevious argument: bool replacePrevious = true; networkObject.SendRpc(RPC_MY_RPC_NAME, replacePrevious, Receivers.AllBuffered, new object[] { args go here });","title":"Replacing Previous Buffered RPCs"},{"location":"NetworkObject/RemoteProcedureCalls/rpc-validation-by-server/","text":"RPC Validation by Server We live in a world where we just can't trust our clients to send us messages that they should be in the way that we wish them to. Clients may want to cheat the system and try to exploit the network for fun or just so that they can win. Because of this we have created a simple method for you to override in order to check any game critical RPCs that are received from the client and verify them. Before continuing with this part of the documentation, please review the Extending Generated Classes documentation to learn more about partial classes. When we use the Network Contract Wizard (NCW), it will create 2 generated classes; one for our MonoBehaviour and one for our NetworkObject . The one that we want to focus on in this example is the generated NetworkObject . So let's say that we opened up the Network Contract Wizard (NCW) and we created a contract named Ball ; this will generate a NetworkObject class named BallNetworkObject . Now in another folder (not in the Generated folder) you will create a new C# script called BallNetworkObject . In here you will create your partial class for the BallNetworkObject and you will override the ServerAllowRpc method like so: ServerAllowRpc namespace BeardedManStudios.Forge.Networking.Generated { public partial class BallNetworkObject : NetworkObject { protected override bool ServerAllowRpc(byte methodId, Receivers receivers, RpcArgs args) { // The methodName is the name of the RPC that is trying to be called right now // The receivers is who the client is trying to send the RPC to // The args are the arguments that were sent as part of the RPC message and what the receivers will receive as arguments to the call } } } Notice that you need to return a boolean from this function. If you return true then the RPC will be allowed to go through, it will be invoked on the server and on the clients (if specified in Receivers). If you return false then the RPC will not be invoked at all and will be dropped.","title":"RPC Validation by Server"},{"location":"NetworkObject/RemoteProcedureCalls/rpc-validation-by-server/#rpc-validation-by-server","text":"We live in a world where we just can't trust our clients to send us messages that they should be in the way that we wish them to. Clients may want to cheat the system and try to exploit the network for fun or just so that they can win. Because of this we have created a simple method for you to override in order to check any game critical RPCs that are received from the client and verify them. Before continuing with this part of the documentation, please review the Extending Generated Classes documentation to learn more about partial classes. When we use the Network Contract Wizard (NCW), it will create 2 generated classes; one for our MonoBehaviour and one for our NetworkObject . The one that we want to focus on in this example is the generated NetworkObject . So let's say that we opened up the Network Contract Wizard (NCW) and we created a contract named Ball ; this will generate a NetworkObject class named BallNetworkObject . Now in another folder (not in the Generated folder) you will create a new C# script called BallNetworkObject . In here you will create your partial class for the BallNetworkObject and you will override the ServerAllowRpc method like so:","title":"RPC Validation by Server"},{"location":"NetworkObject/RemoteProcedureCalls/rpc-validation-by-server/#serverallowrpc","text":"namespace BeardedManStudios.Forge.Networking.Generated { public partial class BallNetworkObject : NetworkObject { protected override bool ServerAllowRpc(byte methodId, Receivers receivers, RpcArgs args) { // The methodName is the name of the RPC that is trying to be called right now // The receivers is who the client is trying to send the RPC to // The args are the arguments that were sent as part of the RPC message and what the receivers will receive as arguments to the call } } } Notice that you need to return a boolean from this function. If you return true then the RPC will be allowed to go through, it will be invoked on the server and on the clients (if specified in Receivers). If you return false then the RPC will not be invoked at all and will be dropped.","title":"ServerAllowRpc"},{"location":"NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/","text":"RpcArgs and RpcInfo Structs When you setup a Remote Procedure Call you will notice that the argument supplied to this is called RpcArgs . This is a struct that helps ease the pain of getting objects from the network byte array. This RpcArgs has a Info member variable which is a RpcInfo struct. This one argument to your RPC helps you get not only the data you sent on the network, but some other useful network meta-data as well. Getting Data From RpcArgs The RpcArgs is a wrapper around the network data with one important method that you actually care about. This method is the RpcArgs::GetNext method. This is an overloaded method with 2 overloads, the first being the parameter-less easy-use method and the other being the more advanced object selection by index method. If you look at the signature for the overload with the int index parameter, you may be thinking \"what is index for?\". This index is the index of the object you wish to pull from the network byte array. So lets say that you called an RPC with 3 arguments (an int, a string, and a float). If you wanted to get the float you could use GetNext float (2) where 2 is the index of arguments. the int being 0 , the string being 1 , and the float being 2 . The power of the parameter-less GetNext T () method is that it auto moves to the next argument. So if you wanted to read the int, string and float from the preceding example you would do the following: int num = args.GetNext int (); string name = args.GetNext string (); float val = args.GetNext float (); Warning!! You must pull out the arguments IN ORDER , if you do not, you will run into an error. So the following WILL NOT work for the same example because of the order of the network data: float val = args.GetNext float (); string name = args.GetNext string (); int num = args.GetNext int (); Using the Info At the time of this writing, the Info member variable in the RpcArgs has 2 properties. A NetworkingPlayer named SendingPlayer and a ulong named TimeStep . The NetworkingPlayer is the sender of this RPC. NOTE This is only useful on the server, clients will always see the server as the sending player since all network traffic first goes though the server. The ulong is used to know what timestamp that this message was sent at from the sender (this is time in milliseconds since the server started). SendingPlayer.Networker.IsServer and SendingPlayer.IsHost You may notice in client execution that the value of SendingPlayer.Networker.IsServer is False but the value of SendingPlayer.IsHost is True and this has caused some confusion for the community. The way that you should think of SendingPlayer.Networker is that it is the NetWorker that is used TO communicate with the server, it is not the server's NetWorker. So if it is the NetWorker used to talk to the server, then it is this client's NetWorker, which makes the IsServer getter False . This is actually why we created the IsHost boolean to help mitigate this confusion and it is less code to get to.","title":"RpcArgs and RpcInfo Structs"},{"location":"NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/#rpcargs-and-rpcinfo-structs","text":"When you setup a Remote Procedure Call you will notice that the argument supplied to this is called RpcArgs . This is a struct that helps ease the pain of getting objects from the network byte array. This RpcArgs has a Info member variable which is a RpcInfo struct. This one argument to your RPC helps you get not only the data you sent on the network, but some other useful network meta-data as well.","title":"RpcArgs and RpcInfo Structs"},{"location":"NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/#getting-data-from-rpcargs","text":"The RpcArgs is a wrapper around the network data with one important method that you actually care about. This method is the RpcArgs::GetNext method. This is an overloaded method with 2 overloads, the first being the parameter-less easy-use method and the other being the more advanced object selection by index method. If you look at the signature for the overload with the int index parameter, you may be thinking \"what is index for?\". This index is the index of the object you wish to pull from the network byte array. So lets say that you called an RPC with 3 arguments (an int, a string, and a float). If you wanted to get the float you could use GetNext float (2) where 2 is the index of arguments. the int being 0 , the string being 1 , and the float being 2 . The power of the parameter-less GetNext T () method is that it auto moves to the next argument. So if you wanted to read the int, string and float from the preceding example you would do the following: int num = args.GetNext int (); string name = args.GetNext string (); float val = args.GetNext float ();","title":"Getting Data From RpcArgs"},{"location":"NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/#warning","text":"You must pull out the arguments IN ORDER , if you do not, you will run into an error. So the following WILL NOT work for the same example because of the order of the network data: float val = args.GetNext float (); string name = args.GetNext string (); int num = args.GetNext int ();","title":"Warning!!"},{"location":"NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/#using-the-info","text":"At the time of this writing, the Info member variable in the RpcArgs has 2 properties. A NetworkingPlayer named SendingPlayer and a ulong named TimeStep . The NetworkingPlayer is the sender of this RPC. NOTE This is only useful on the server, clients will always see the server as the sending player since all network traffic first goes though the server. The ulong is used to know what timestamp that this message was sent at from the sender (this is time in milliseconds since the server started).","title":"Using the Info"},{"location":"NetworkObject/RemoteProcedureCalls/rpcargs-and-rpcinfo-structs/#sendingplayernetworkerisserver-and-sendingplayerishost","text":"You may notice in client execution that the value of SendingPlayer.Networker.IsServer is False but the value of SendingPlayer.IsHost is True and this has caused some confusion for the community. The way that you should think of SendingPlayer.Networker is that it is the NetWorker that is used TO communicate with the server, it is not the server's NetWorker. So if it is the NetWorker used to talk to the server, then it is this client's NetWorker, which makes the IsServer getter False . This is actually why we created the IsHost boolean to help mitigate this confusion and it is less code to get to.","title":"SendingPlayer.Networker.IsServer and SendingPlayer.IsHost"},{"location":"NetworkObject/RemoteProcedureCalls/sending-rpc-to-a-single-player/","text":"Sending RPC to a Single Player During your development process you may find that you have to send an RPC to a single player and nobody else. This is especially useful to target players that are just connecting to the server to send them needed data that is not buffered already. General Example // targetPlayer is a NetworkingPlayer refence we got from the NetWorker::Players list or anywhere else // args is an object array networkObject.SendRpc(targetPlayer, RPC_RPC_NAME, args); Player Accept (join) Example // Somewhere in your code if (networker.IsServer) networker.playerAccepted += PlayerAcceptedSetup; // ... private void PlayerAcceptedSetup(NetworkingPlayer newPlayer, Networker sender) { networkObject.SendRpc(newPlayer, RPC_RPC_NAME, args); } Notes This player targeting with RPCs are done on the server. Clients do not have direct access to each other since all network traffic goes through the server (which makes it authoritative ). You can use Receivers.Owner to target the owning player of the network object from any client though.","title":"Sending RPC to a Single Player"},{"location":"NetworkObject/RemoteProcedureCalls/sending-rpc-to-a-single-player/#sending-rpc-to-a-single-player","text":"During your development process you may find that you have to send an RPC to a single player and nobody else. This is especially useful to target players that are just connecting to the server to send them needed data that is not buffered already.","title":"Sending RPC to a Single Player"},{"location":"NetworkObject/RemoteProcedureCalls/sending-rpc-to-a-single-player/#general-example","text":"// targetPlayer is a NetworkingPlayer refence we got from the NetWorker::Players list or anywhere else // args is an object array networkObject.SendRpc(targetPlayer, RPC_RPC_NAME, args);","title":"General Example"},{"location":"NetworkObject/RemoteProcedureCalls/sending-rpc-to-a-single-player/#player-accept-join-example","text":"// Somewhere in your code if (networker.IsServer) networker.playerAccepted += PlayerAcceptedSetup; // ... private void PlayerAcceptedSetup(NetworkingPlayer newPlayer, Networker sender) { networkObject.SendRpc(newPlayer, RPC_RPC_NAME, args); }","title":"Player Accept (join) Example"},{"location":"NetworkObject/RemoteProcedureCalls/sending-rpc-to-a-single-player/#notes","text":"This player targeting with RPCs are done on the server. Clients do not have direct access to each other since all network traffic goes through the server (which makes it authoritative ). You can use Receivers.Owner to target the owning player of the network object from any client though.","title":"Notes"},{"location":"SceneNavigation/loading-scenes/","text":"Loading Scenes One of the things that you may be worrying about is how you can load into new scenes on the network. Some issues you may worry about are: How do clients know when to change scenes? How do I clean up all the network objects? How do clients know what scene to go to? How do newly connected clients know what scene is currently active? How do I handle additive scenes? These are all good questions and also all questions that you don't have to worry about in Forge Networking. We hook into Unity's SceneManager.sceneLoaded event so that we can detect when the scene changes or new scenes are additively loaded on the server. Once the server detects this scene change it will tell all the connected clients to change to the new scene that the server has loaded. If an additional scene was loaded on the server, the server then tells the clients to also additively load the scene. Also the server keeps track of the scenes that are currently active so that it can send them down to the newly accepted client who just connected. There are a few important notes about scenes with Forge Networking: The server must load the scene to trigger all of the clients to load scenes Clients can still load scenes without the server having to dictate the change, however when the server changes the scene it will get pushed to the client and overwrite the changes You load scenes as you normally would do in Unity on the server, no extra calls are needed Below is a sample of how to load a scene on the server only if both the server and client are sharing code. The Networker in this case will be a reference to the NetWorker in NetworkManager.Instance.Networker . Loading a single scene on the server // This will load scene at build index 1 only if this is the server's code if (Networker.IsServer) SceneManager.LoadScene(1, LoadSceneMode.Single); Async loading a single scene on the server // This will load scene at build index 1 only if this is the server's code if (Networker.IsServer) SceneManager.LoadSceneAsync(1, LoadSceneMode.Single); Loading an additional scene on the server // This will load scene at build index 1 only if this is the server's code if (Networker.IsServer) SceneManager.LoadScene(1, LoadSceneMode.Additive); Async loading an additional scene on the server // This will load scene at build index 1 only if this is the server's code if (Networker.IsServer) SceneManager.LoadSceneAsync(1, LoadSceneMode.Additive);","title":"Loading Scenes"},{"location":"SceneNavigation/loading-scenes/#loading-scenes","text":"One of the things that you may be worrying about is how you can load into new scenes on the network. Some issues you may worry about are: How do clients know when to change scenes? How do I clean up all the network objects? How do clients know what scene to go to? How do newly connected clients know what scene is currently active? How do I handle additive scenes? These are all good questions and also all questions that you don't have to worry about in Forge Networking. We hook into Unity's SceneManager.sceneLoaded event so that we can detect when the scene changes or new scenes are additively loaded on the server. Once the server detects this scene change it will tell all the connected clients to change to the new scene that the server has loaded. If an additional scene was loaded on the server, the server then tells the clients to also additively load the scene. Also the server keeps track of the scenes that are currently active so that it can send them down to the newly accepted client who just connected. There are a few important notes about scenes with Forge Networking: The server must load the scene to trigger all of the clients to load scenes Clients can still load scenes without the server having to dictate the change, however when the server changes the scene it will get pushed to the client and overwrite the changes You load scenes as you normally would do in Unity on the server, no extra calls are needed Below is a sample of how to load a scene on the server only if both the server and client are sharing code. The Networker in this case will be a reference to the NetWorker in NetworkManager.Instance.Networker .","title":"Loading Scenes"},{"location":"SceneNavigation/loading-scenes/#loading-a-single-scene-on-the-server","text":"// This will load scene at build index 1 only if this is the server's code if (Networker.IsServer) SceneManager.LoadScene(1, LoadSceneMode.Single);","title":"Loading a single scene on the server"},{"location":"SceneNavigation/loading-scenes/#async-loading-a-single-scene-on-the-server","text":"// This will load scene at build index 1 only if this is the server's code if (Networker.IsServer) SceneManager.LoadSceneAsync(1, LoadSceneMode.Single);","title":"Async loading a single scene on the server"},{"location":"SceneNavigation/loading-scenes/#loading-an-additional-scene-on-the-server","text":"// This will load scene at build index 1 only if this is the server's code if (Networker.IsServer) SceneManager.LoadScene(1, LoadSceneMode.Additive);","title":"Loading an additional scene on the server"},{"location":"SceneNavigation/loading-scenes/#async-loading-an-additional-scene-on-the-server","text":"// This will load scene at build index 1 only if this is the server's code if (Networker.IsServer) SceneManager.LoadSceneAsync(1, LoadSceneMode.Additive);","title":"Async loading an additional scene on the server"},{"location":"SceneNavigation/scene-events/","text":"Scene Events There are some events that you can register to in order to know the flow of the scene loading events. Below are a list of the available events to hook into for scene loading and short descriptions of what they are for. Note All of these events are available through the NetworkManager.Instance so for example playerLoadedScene would be NetworkManager.Instance.playerLoadedScene . playerLoadedScene This is used on the server to know when a specific player has finished loading into a level. networkSceneChanging This is used on the client to know if it has been told by the server to change the scene. This happens just before the scene change is invoked. networkSceneLoaded This is used on the client and the server to know when the scene has been successfully loaded and is ready to begin with networking code (starting with spawning Network Objects).","title":"Scene Events"},{"location":"SceneNavigation/scene-events/#scene-events","text":"There are some events that you can register to in order to know the flow of the scene loading events. Below are a list of the available events to hook into for scene loading and short descriptions of what they are for. Note All of these events are available through the NetworkManager.Instance so for example playerLoadedScene would be NetworkManager.Instance.playerLoadedScene .","title":"Scene Events"},{"location":"SceneNavigation/scene-events/#playerloadedscene","text":"This is used on the server to know when a specific player has finished loading into a level.","title":"playerLoadedScene"},{"location":"SceneNavigation/scene-events/#networkscenechanging","text":"This is used on the client to know if it has been told by the server to change the scene. This happens just before the scene change is invoked.","title":"networkSceneChanging"},{"location":"SceneNavigation/scene-events/#networksceneloaded","text":"This is used on the client and the server to know when the scene has been successfully loaded and is ready to begin with networking code (starting with spawning Network Objects).","title":"networkSceneLoaded"},{"location":"Troubleshooting/throttling-network-internal/","text":"Throttling Network Internal So there are many tools out there to download and use to test applications and the general stability of networks, however we wanted to go over some quick and easy ways that you can test the network using just Forge Networking. Network Latency Simulation The network latency simulation lets you test how your code would behave if there were to be network latency. This is a very simple tool that makes it so that the core of Forge will delay the reading/sending of messages by the given milliseconds. This is useful to test and see how clients with slow networks will experience your game. The latency simulation is per NetWorker so to test this out quickly you can use NetworkManager.Instance.Networker . Below is a sample of how to set the latency to 900 milliseconds (0.9 seconds): // Somewhere in code, even during runtime NetworkManager.Instance.Networker.LatencySimulation = 900; // 900 is the time in milliseconds Packet Loss Simulation The packet loss simulation lets you test how your code would behave if there were to be packet loss of a specific chance. This tool allows you to set a percentage of packet loss. What this does internally is generate a random number, if it is within the specified percentage then it will delete the packet and ignore reading it. This will allow you to test your code to see what would happen if you were to lose packets during gameplay. The packet loss simulation is per NetWorker so to test this out quickly you can use NetworkManager.Instance.Networker . Below is a sample of how to set the percentage to 0.1f (10% packet loss chance): // Somewhere in code, even during runtime NetworkManager.Instance.Networker.PacketLossSimulation = 0.1f; // 0.1f is the percentage chance of packet loss (10% in this case)","title":"Throttling Network Internal"},{"location":"Troubleshooting/throttling-network-internal/#throttling-network-internal","text":"So there are many tools out there to download and use to test applications and the general stability of networks, however we wanted to go over some quick and easy ways that you can test the network using just Forge Networking.","title":"Throttling Network Internal"},{"location":"Troubleshooting/throttling-network-internal/#network-latency-simulation","text":"The network latency simulation lets you test how your code would behave if there were to be network latency. This is a very simple tool that makes it so that the core of Forge will delay the reading/sending of messages by the given milliseconds. This is useful to test and see how clients with slow networks will experience your game. The latency simulation is per NetWorker so to test this out quickly you can use NetworkManager.Instance.Networker . Below is a sample of how to set the latency to 900 milliseconds (0.9 seconds): // Somewhere in code, even during runtime NetworkManager.Instance.Networker.LatencySimulation = 900; // 900 is the time in milliseconds","title":"Network Latency Simulation"},{"location":"Troubleshooting/throttling-network-internal/#packet-loss-simulation","text":"The packet loss simulation lets you test how your code would behave if there were to be packet loss of a specific chance. This tool allows you to set a percentage of packet loss. What this does internally is generate a random number, if it is within the specified percentage then it will delete the packet and ignore reading it. This will allow you to test your code to see what would happen if you were to lose packets during gameplay. The packet loss simulation is per NetWorker so to test this out quickly you can use NetworkManager.Instance.Networker . Below is a sample of how to set the percentage to 0.1f (10% packet loss chance): // Somewhere in code, even during runtime NetworkManager.Instance.Networker.PacketLossSimulation = 0.1f; // 0.1f is the percentage chance of packet loss (10% in this case)","title":"Packet Loss Simulation"},{"location":"Troubleshooting/troubleshooting/","text":"Troubleshooting Network Issues If you are having trouble setting up your network, or you are having trouble connecting your game, please review this page and follow the steps completely. There are many stages of network communication that you can troubleshoot to test your game. In this document we will go over the various steps to troubleshooting so that you can figure out what could be wrong with the setup on your machine, local network, or internet connections. The Local Machine The primary method of testing your game will most likely be on a single machine which is often your development machine. The addresses 127.0.0.1 , localhost , ::0 , etc. are all references to the machine you are currently on. These addresses are used for local testing, routing, security, and other probably less common practices. Steps to test: 1. Turn on \"Run in Background\" in Unity Player Settings 2. Set the Multiplayer Menu scene as the first scene 3. Use the CubeForge demo scene as the second scene 4. Build your game from Unity 5. Run 1 instance of your build and play the other instance in the Unity Editor 6. Press play in the Editor 7. Host a server in the Editor on port 15937 8. Run the built instance of the application 9. Connect to IP address 127.0.0.1 and port number 15937 on the built instance If you can connect, CONGRATULATIONS , your game is properly networked and your machine is properly setup to test your game on the local machine. If you are having trouble with this stage, please ensure that you are properly following the steps above and building the instance. The Local Area Network (LAN) If the local machine setup above is working correctly and your local area network (LAN) is not, chances are there is an issue with your network or machine firewall. Follow the above steps except run the instance of the game that was built on another machine on your network. We will refer to the machine that the Unity Editor (server) is on as Server and the second machine that is on the network which is running the built instance Client . Host the server on Server Try to connect using Client If the above steps fail to connect and play the game, you have 1 or more of the following problems with your network setup. Your machine firewall on Server is not allowing the connections Your machines are not on the same network You are not supplying the correct IP address or Port number # Issue 1 Resolution First, let's find out if your issue is the one listed as #1. Open your firewall settings on your local machine, locate the Unity Editor in the firewall settings and make sure it is allowing connections. If you are not sure how to check or change your firewall settings, please reference Google to learn the steps for your operating system. NOTE : If you are not hosting in the Unity Editor, these same steps would apply to the build game, you just need to locate the game name in the firewall settings. If it is not found, you need to add the exception to your machine firewall with the same steps as mentioned above. # Issue 2 Resolution For (#2) you are going to have to make sure that the two machines are on the same exact network. You can do this by making sure that the router name (when connecting) is the same for both machines (when connecting via Wi-Fi). If you are using a Ethernet cable, make sure that both cables for both machines are leading into the same router. If you are using Ethernet for one machine and Wi-Fi for another machine, make sure that the Wi-Fi connected machine is connecting to the same router name as the machine that has the Ethernet cord connected to the router. # Issue 3 Resolution When connecting to Server , you are required to input the correct IP address. For the Server machine, you should be hosting on 0.0.0.0 for this test; if you are not sure what that means, then you are already set to that and do not need to worry about it as you've not set it explicitly yourself. First, you need to open the network configuration on Server . You can do this by opening a command prompt or a terminal window. The following is the command that you would input onto a Windows Command Prompt window to find your local area networks IP address. ipconfig The following is the command that you would input onto a MacOS/Linux Terminal window to find your local area networks IP address. ifconfig Locate the LAN that you are connected to and find the IPv4 address that is assigned to the Server . This is the IP address that you need to input into your Client for the host address. The port number should still be 15937 as mentioned in the previous example. NOTE : If you use machine virtualization (VM or Virtual Machine's) then there may be multiple network IPv4 addresses when you enter the above command. This is also the case if you using both Ethernet and Wi-Fi, so please be sure to select the correct network address. Usually the name showed in the listings is indicative to the connection type. The Internet Cloud Servers Chances are that if the above are working perfectly, then there are one of two things that could not be working for you. 1) The server machine's firewall is not opened for the application. Please see the above on how to fix this or 2) The network firewall settings are not allowing the port For #2 you will need to review with your cloud hosting provider on how to open the ports for your application/machine. This is done differently through each provider but should be an easy Google Search away from finding out. Let's say that you are hosting through Microsoft Azure, you would search Google as follows: Azure open network ports or Azure open ports and endpoints These queries should produce some fine results. MAKE SURE to replace \"Azure\" with your cloud hosting provider, like \"EC2\" or \"Rackspace\".","title":"Troubleshooting"},{"location":"Troubleshooting/troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Troubleshooting/troubleshooting/#network-issues","text":"If you are having trouble setting up your network, or you are having trouble connecting your game, please review this page and follow the steps completely. There are many stages of network communication that you can troubleshoot to test your game. In this document we will go over the various steps to troubleshooting so that you can figure out what could be wrong with the setup on your machine, local network, or internet connections.","title":"Network Issues"},{"location":"Troubleshooting/troubleshooting/#the-local-machine","text":"The primary method of testing your game will most likely be on a single machine which is often your development machine. The addresses 127.0.0.1 , localhost , ::0 , etc. are all references to the machine you are currently on. These addresses are used for local testing, routing, security, and other probably less common practices. Steps to test: 1. Turn on \"Run in Background\" in Unity Player Settings 2. Set the Multiplayer Menu scene as the first scene 3. Use the CubeForge demo scene as the second scene 4. Build your game from Unity 5. Run 1 instance of your build and play the other instance in the Unity Editor 6. Press play in the Editor 7. Host a server in the Editor on port 15937 8. Run the built instance of the application 9. Connect to IP address 127.0.0.1 and port number 15937 on the built instance If you can connect, CONGRATULATIONS , your game is properly networked and your machine is properly setup to test your game on the local machine. If you are having trouble with this stage, please ensure that you are properly following the steps above and building the instance.","title":"The Local Machine"},{"location":"Troubleshooting/troubleshooting/#the-local-area-network-lan","text":"If the local machine setup above is working correctly and your local area network (LAN) is not, chances are there is an issue with your network or machine firewall. Follow the above steps except run the instance of the game that was built on another machine on your network. We will refer to the machine that the Unity Editor (server) is on as Server and the second machine that is on the network which is running the built instance Client . Host the server on Server Try to connect using Client If the above steps fail to connect and play the game, you have 1 or more of the following problems with your network setup. Your machine firewall on Server is not allowing the connections Your machines are not on the same network You are not supplying the correct IP address or Port number","title":"The Local Area Network (LAN)"},{"location":"Troubleshooting/troubleshooting/#issue-1-resolution","text":"First, let's find out if your issue is the one listed as #1. Open your firewall settings on your local machine, locate the Unity Editor in the firewall settings and make sure it is allowing connections. If you are not sure how to check or change your firewall settings, please reference Google to learn the steps for your operating system. NOTE : If you are not hosting in the Unity Editor, these same steps would apply to the build game, you just need to locate the game name in the firewall settings. If it is not found, you need to add the exception to your machine firewall with the same steps as mentioned above.","title":"# Issue 1 Resolution"},{"location":"Troubleshooting/troubleshooting/#issue-2-resolution","text":"For (#2) you are going to have to make sure that the two machines are on the same exact network. You can do this by making sure that the router name (when connecting) is the same for both machines (when connecting via Wi-Fi). If you are using a Ethernet cable, make sure that both cables for both machines are leading into the same router. If you are using Ethernet for one machine and Wi-Fi for another machine, make sure that the Wi-Fi connected machine is connecting to the same router name as the machine that has the Ethernet cord connected to the router.","title":"# Issue 2 Resolution"},{"location":"Troubleshooting/troubleshooting/#issue-3-resolution","text":"When connecting to Server , you are required to input the correct IP address. For the Server machine, you should be hosting on 0.0.0.0 for this test; if you are not sure what that means, then you are already set to that and do not need to worry about it as you've not set it explicitly yourself. First, you need to open the network configuration on Server . You can do this by opening a command prompt or a terminal window. The following is the command that you would input onto a Windows Command Prompt window to find your local area networks IP address. ipconfig The following is the command that you would input onto a MacOS/Linux Terminal window to find your local area networks IP address. ifconfig Locate the LAN that you are connected to and find the IPv4 address that is assigned to the Server . This is the IP address that you need to input into your Client for the host address. The port number should still be 15937 as mentioned in the previous example. NOTE : If you use machine virtualization (VM or Virtual Machine's) then there may be multiple network IPv4 addresses when you enter the above command. This is also the case if you using both Ethernet and Wi-Fi, so please be sure to select the correct network address. Usually the name showed in the listings is indicative to the connection type.","title":"# Issue 3 Resolution"},{"location":"Troubleshooting/troubleshooting/#the-internet-cloud-servers","text":"Chances are that if the above are working perfectly, then there are one of two things that could not be working for you. 1) The server machine's firewall is not opened for the application. Please see the above on how to fix this or 2) The network firewall settings are not allowing the port For #2 you will need to review with your cloud hosting provider on how to open the ports for your application/machine. This is done differently through each provider but should be an easy Google Search away from finding out. Let's say that you are hosting through Microsoft Azure, you would search Google as follows: Azure open network ports or Azure open ports and endpoints These queries should produce some fine results. MAKE SURE to replace \"Azure\" with your cloud hosting provider, like \"EC2\" or \"Rackspace\".","title":"The Internet &amp; Cloud Servers"},{"location":"UnityIntegration/gameobject-execution-order/","text":"GameObject Execution Order You may be use to the standard method execution order in Unity and this can cause some confusion when it comes to when you are able to access the network object on a client. You see, when you create a network object on the client it takes some time to get to the server, validate, and return back to the client. Because of this, the networkObject you are use to using may be null during the Start and Awake methods of your MonoBehaviour. NetworkStart To resolve the issue with starting things once the networkObject has been setup, we have created a protected method you can override that will be called once the networkObject has been setup. You should do any initialization logic that is required for the network object in this method. Don't forget to call the base.NetworkStart() method . protected override void NetworkStart() { base.NetworkStart(); // TODO: Your initialization code that relies on network setup for this object goes here } Update and FixedUpdate If the network is a little slow, it is very possible that the networkObject is not setup by the time the first call to the Update or FixedUpdate happens in Unity. So make sure to do your null checks or set some-kind of flag for when the object is ready to be used. private void Update() { if (networkObject != null) { // TODO: Whatever you need to do with the networkObject } }","title":"GameObject Execution Order"},{"location":"UnityIntegration/gameobject-execution-order/#gameobject-execution-order","text":"You may be use to the standard method execution order in Unity and this can cause some confusion when it comes to when you are able to access the network object on a client. You see, when you create a network object on the client it takes some time to get to the server, validate, and return back to the client. Because of this, the networkObject you are use to using may be null during the Start and Awake methods of your MonoBehaviour.","title":"GameObject Execution Order"},{"location":"UnityIntegration/gameobject-execution-order/#networkstart","text":"To resolve the issue with starting things once the networkObject has been setup, we have created a protected method you can override that will be called once the networkObject has been setup. You should do any initialization logic that is required for the network object in this method. Don't forget to call the base.NetworkStart() method . protected override void NetworkStart() { base.NetworkStart(); // TODO: Your initialization code that relies on network setup for this object goes here }","title":"NetworkStart"},{"location":"UnityIntegration/gameobject-execution-order/#update-and-fixedupdate","text":"If the network is a little slow, it is very possible that the networkObject is not setup by the time the first call to the Update or FixedUpdate happens in Unity. So make sure to do your null checks or set some-kind of flag for when the object is ready to be used. private void Update() { if (networkObject != null) { // TODO: Whatever you need to do with the networkObject } }","title":"Update and FixedUpdate"},{"location":"UnityIntegration/main-threading-rpcs/","text":"Main Threading RPCs The RPC behaviors in Forge Networking work on the network reading thread for purposes of performance when it comes to reading network data. This means that accessing any Unity specific objects in this thread will cause an error (please see Threading in Unity ). Many of our newer users will be unconformable working with function pointers, lambda expressions or threading so we have created an easy way for you to make all RPC calls perform on the main thread. At any point in your application you can assign the Rpc's MainThreadRunner object. By doing this you will essentially make all incoming RPC calls run on Unity's main thread. To do this you would do the following in your code. For an example of this, please see the MultiplayerMenu.cs file and follow the useMainThreadManagerForRPCs variable if you wish to manually say when to run an RPC on the main thread. You can always use the MainThreadManage.Run method to queue actions to perform on the main thread. To understand this further, please review Threading in Unity .","title":"Main Threading RPCs"},{"location":"UnityIntegration/main-threading-rpcs/#main-threading-rpcs","text":"The RPC behaviors in Forge Networking work on the network reading thread for purposes of performance when it comes to reading network data. This means that accessing any Unity specific objects in this thread will cause an error (please see Threading in Unity ). Many of our newer users will be unconformable working with function pointers, lambda expressions or threading so we have created an easy way for you to make all RPC calls perform on the main thread. At any point in your application you can assign the Rpc's MainThreadRunner object. By doing this you will essentially make all incoming RPC calls run on Unity's main thread. To do this you would do the following in your code. For an example of this, please see the MultiplayerMenu.cs file and follow the useMainThreadManagerForRPCs variable if you wish to manually say when to run an RPC on the main thread. You can always use the MainThreadManage.Run method to queue actions to perform on the main thread. To understand this further, please review Threading in Unity .","title":"Main Threading RPCs"},{"location":"UnityIntegration/network-instantiation/","text":"Network Instantiation Network instantiation is how you are able to create objects on the network so that all other clients are able to see that object. Then you can update this object or send Remote Procedure Calls to the object to perform behaviors across the network or manage local behaviors. When you use the Network Contract Wizard you are able to generate what is known as a \"Network Object\". These objects can then be extended to have custom behavior and to implement network behaviors defined in the Network Contract Wizard (NCW). When you click the \"Save Compile\" option in the NCW, an instantiate method will be created for the object you just defined in the NCW. So if you created a Network Object in the NCW named SuperBall then you could call the following code in Unity to create an instance of that SuperBall : NetworkManager.Instance.InstantiateSuperBall(); If you look at the input parameters of this method you will find that there are a few optional parameters: 1. int index = 0 2. Vector3? position = null 3. Quaternion? rotation = null 4. bool sendTransform = true The index tells the network which prefab to instantiate (from the array set in the Network Manager prefab). This is the position you wish to spawn the prefab at on the network. If left null then the object will spawn at the coordinates set in the prefab. This is the rotation you wish to spawn the prefab at on the network. If left null then the object will spawn at the rotation set in the prefab. This is used to know if the transform that is being assigned should be sent across the network. So if you filled out #2 and #3 then those values will be sent across the network and not just used locally. If you pass false then the prefab will spawn on the caller at the specified location, but it will be spawned at the prefab location on the other clients. You may recall from the above #1 that you can set various prefabs to spawn for a given network object. That is to say that my SuperBall could have more than one prefab it spawns on, even a cube (I know crazy right?). To work with this you will need to locate the NetworkManager prefab in the Bearded Man Studios Inc/Prefabs folder. Once you select this prefab, you will notice that there is a NetworkPrefab component attached to it with a Super Ball Network Object array that is empty. This is where you will drag and drop the various prefabs you wish to use as this type of network object. So we can drag a sphere and even a cube into this array. Let's say that we first put a sphere into the array and then we put a cube into the array. You will notice that the sphere has an index of 0 and the cube will have an index of 1 . This is the value that you will supply to the instantiate method when you call it. If you were to pass 0 , you would get a sphere and if you were to pass a 1 you would get a cube. Getting the GameObject From Instantiate What you may notice is that when you instantiate the SuperBall it will return a NetworkBehavior which will be your SuperBallBehavior that was generated. This object actually derives from the MonoBehaviour so you can directly access the gameObject, transform, and any standard MonoBehaviour field, property, and method as you would do normally. var ball = NetworkManager.Instance.InstantiateSuperBall(); // Access any standard MonoBehaviour elements as seen below from the ball reference Debug.Log(ball.gameObject.name); Debug.Log(ball.transform.position); Notes So you may be thinking, well gee, a numbered index might be a little bit hard to keep track of, and if you do, then you are probably correct. Like all things software there are many ways that you can setup your project, but here are just 2 ideas that you can use to have a little better time managing the various prefabs you may use. Method 1 You can create a class that is dedicated to mapping objects to strings or integers. Then you can access the NetworkManager.Instance and assign the array directly with NetworkManager.Instance.SuperBallNetworkObject = myArray; . By doing this you can create your own indexing and lookup logic for the prefabs that you can use to easily find the index for the prefab that should spawn on the network. After creating the mapping you just need to call your lookup method and have it do the rest of the work. Method 2 You can create your own instantiate methods. You can wrap code around our code to spawn your objects. So imagine that you want to call the generated NetworkManager.Instance.InstantiateSuperBall method but you have some other stuff you always do before hand or that dynamically selects the proper index. In this case you can create a class that does all the helper logic before you call the instantiate method, then you would call the instantiate through this helper class. Manual Attachment Method You can create a NetworkObject without having to call this instantiate method which is directly linked to a prefab. This obviously isn't a topic for this section but you can find out more about this in the Getting Started examples about network instantiation. Warnings If you are dynamically setting the array on the NetworkManager.Instance then you MUST make sure that the order being assigned is predictable on all clients. You can't exactly have the order of the array different on each client and expect it to still work properly can you?","title":"Network Instantiation"},{"location":"UnityIntegration/network-instantiation/#network-instantiation","text":"Network instantiation is how you are able to create objects on the network so that all other clients are able to see that object. Then you can update this object or send Remote Procedure Calls to the object to perform behaviors across the network or manage local behaviors. When you use the Network Contract Wizard you are able to generate what is known as a \"Network Object\". These objects can then be extended to have custom behavior and to implement network behaviors defined in the Network Contract Wizard (NCW). When you click the \"Save Compile\" option in the NCW, an instantiate method will be created for the object you just defined in the NCW. So if you created a Network Object in the NCW named SuperBall then you could call the following code in Unity to create an instance of that SuperBall : NetworkManager.Instance.InstantiateSuperBall(); If you look at the input parameters of this method you will find that there are a few optional parameters: 1. int index = 0 2. Vector3? position = null 3. Quaternion? rotation = null 4. bool sendTransform = true The index tells the network which prefab to instantiate (from the array set in the Network Manager prefab). This is the position you wish to spawn the prefab at on the network. If left null then the object will spawn at the coordinates set in the prefab. This is the rotation you wish to spawn the prefab at on the network. If left null then the object will spawn at the rotation set in the prefab. This is used to know if the transform that is being assigned should be sent across the network. So if you filled out #2 and #3 then those values will be sent across the network and not just used locally. If you pass false then the prefab will spawn on the caller at the specified location, but it will be spawned at the prefab location on the other clients. You may recall from the above #1 that you can set various prefabs to spawn for a given network object. That is to say that my SuperBall could have more than one prefab it spawns on, even a cube (I know crazy right?). To work with this you will need to locate the NetworkManager prefab in the Bearded Man Studios Inc/Prefabs folder. Once you select this prefab, you will notice that there is a NetworkPrefab component attached to it with a Super Ball Network Object array that is empty. This is where you will drag and drop the various prefabs you wish to use as this type of network object. So we can drag a sphere and even a cube into this array. Let's say that we first put a sphere into the array and then we put a cube into the array. You will notice that the sphere has an index of 0 and the cube will have an index of 1 . This is the value that you will supply to the instantiate method when you call it. If you were to pass 0 , you would get a sphere and if you were to pass a 1 you would get a cube.","title":"Network Instantiation"},{"location":"UnityIntegration/network-instantiation/#getting-the-gameobject-from-instantiate","text":"What you may notice is that when you instantiate the SuperBall it will return a NetworkBehavior which will be your SuperBallBehavior that was generated. This object actually derives from the MonoBehaviour so you can directly access the gameObject, transform, and any standard MonoBehaviour field, property, and method as you would do normally. var ball = NetworkManager.Instance.InstantiateSuperBall(); // Access any standard MonoBehaviour elements as seen below from the ball reference Debug.Log(ball.gameObject.name); Debug.Log(ball.transform.position);","title":"Getting the GameObject From Instantiate"},{"location":"UnityIntegration/network-instantiation/#notes","text":"So you may be thinking, well gee, a numbered index might be a little bit hard to keep track of, and if you do, then you are probably correct. Like all things software there are many ways that you can setup your project, but here are just 2 ideas that you can use to have a little better time managing the various prefabs you may use.","title":"Notes"},{"location":"UnityIntegration/network-instantiation/#method-1","text":"You can create a class that is dedicated to mapping objects to strings or integers. Then you can access the NetworkManager.Instance and assign the array directly with NetworkManager.Instance.SuperBallNetworkObject = myArray; . By doing this you can create your own indexing and lookup logic for the prefabs that you can use to easily find the index for the prefab that should spawn on the network. After creating the mapping you just need to call your lookup method and have it do the rest of the work.","title":"Method 1"},{"location":"UnityIntegration/network-instantiation/#method-2","text":"You can create your own instantiate methods. You can wrap code around our code to spawn your objects. So imagine that you want to call the generated NetworkManager.Instance.InstantiateSuperBall method but you have some other stuff you always do before hand or that dynamically selects the proper index. In this case you can create a class that does all the helper logic before you call the instantiate method, then you would call the instantiate through this helper class.","title":"Method 2"},{"location":"UnityIntegration/network-instantiation/#manual-attachment-method","text":"You can create a NetworkObject without having to call this instantiate method which is directly linked to a prefab. This obviously isn't a topic for this section but you can find out more about this in the Getting Started examples about network instantiation.","title":"Manual Attachment Method"},{"location":"UnityIntegration/network-instantiation/#warnings","text":"If you are dynamically setting the array on the NetworkManager.Instance then you MUST make sure that the order being assigned is predictable on all clients. You can't exactly have the order of the array different on each client and expect it to still work properly can you?","title":"Warnings"},{"location":"UnityIntegration/network-start/","text":"Unity Integration Network Start Since Unity does not work as fast as Forge Networking, there are a few control flow features that we've added into the Unity Integration to allow you to plan your network setup for network objects. When you implement your generated Behavior script that was generated from the NCW , you can override a function named NetworkStart . When the NetworkStart function is called, that means the object has been setup on the network and is ready to do things like send RPCs, update fields, etc. Below is an example of how to override the NetworkStart method in order to disable a camera on a game object that is not owned by the current instance and set our fields update interval. using BeardedManStudios.Forge.Networking.Generated; using UnityEngine; public class NetCam : NetworkCameraBehavior { protected override void NetworkStart() { base.NetworkStart(); cameraRef = GetComponent Camera (); networkObject.UpdateInterval = 100; // If this is not our camera then we should not render using it if (!networkObject.IsOwner) cameraRef.enabled = false; } } networkStarted Event For your convenience, we've added a networkStarted event to NetworkBehavior so that you can do other operations on other objects that have a reference to the object in question. For example; if you instantiate the object (obviously from another script) and you want to do some special action on that object once it has been setup on the network, you can hook into this event. var cameraPlayer = NetworkManager.Instance.InstantiateNetworkCamera(); cameraPlayer.networkStarted += CameraReadyOnNetwork; // ... private void CameraReadyOnNetwork(NetworkBehavior playerCamera) { UnityEngine.Debug.Log( The player camera + playerCamera.name + has been setup on the network ); }","title":"Unity Integration Network Start"},{"location":"UnityIntegration/network-start/#unity-integration-network-start","text":"Since Unity does not work as fast as Forge Networking, there are a few control flow features that we've added into the Unity Integration to allow you to plan your network setup for network objects. When you implement your generated Behavior script that was generated from the NCW , you can override a function named NetworkStart . When the NetworkStart function is called, that means the object has been setup on the network and is ready to do things like send RPCs, update fields, etc. Below is an example of how to override the NetworkStart method in order to disable a camera on a game object that is not owned by the current instance and set our fields update interval. using BeardedManStudios.Forge.Networking.Generated; using UnityEngine; public class NetCam : NetworkCameraBehavior { protected override void NetworkStart() { base.NetworkStart(); cameraRef = GetComponent Camera (); networkObject.UpdateInterval = 100; // If this is not our camera then we should not render using it if (!networkObject.IsOwner) cameraRef.enabled = false; } }","title":"Unity Integration Network Start"},{"location":"UnityIntegration/network-start/#networkstarted-event","text":"For your convenience, we've added a networkStarted event to NetworkBehavior so that you can do other operations on other objects that have a reference to the object in question. For example; if you instantiate the object (obviously from another script) and you want to do some special action on that object once it has been setup on the network, you can hook into this event. var cameraPlayer = NetworkManager.Instance.InstantiateNetworkCamera(); cameraPlayer.networkStarted += CameraReadyOnNetwork; // ... private void CameraReadyOnNetwork(NetworkBehavior playerCamera) { UnityEngine.Debug.Log( The player camera + playerCamera.name + has been setup on the network ); }","title":"networkStarted Event"},{"location":"UnityIntegration/running-unity-specific-code-on-the-main-thread/","text":"Running Unity specific code on the main thread We have created a helper class for you to be able to offload any logic to the main thread from a separate thread. This helper class is called MainThreadManager and there are 2 main ways that you can use this class. The entry point for both methods of use is the static method Run ; see the code snippets below for practical uses. The examples below emulate an RPC method's contents. MainThreadManager.Run Function Pointer public override void MyCustomRPC(object[] args) { // Register the private function within this class to be called on the main thread MainThreadManager.Run(OtherFunction); } private void OtherFunction() { Debug.Log( Hello World! ); } You can see that the above example requires another accessible method in order to pass it into the main thread manager's Run method. MainThreadManager.Run Lambda Expression public override void MyCustomRPC(object[] args) { // Setup a temporary method call (lambda expression) to be executed on the main thread MainThreadManager.Run(() = { Debug.Log( Hello World! ); }); } The above is the preferred method The lambda expression is a native C# feature that allows you to essentially create an inline function at runtime. Please see this website or the official documentation for more information on lambda expressions. What does the Main Thread Manager do? The Main Thread Manager is actually a pretty small and simple singleton class. When you send a method pointer or inline expression into the Run method it will be added to a queue. The Main Thread Manager is a Unity GameObject and will automatically create itself if one is not created already. Every FixedUpdate for this object, it will check to see if there are any pending methods in the queue, if so it will run them and remove them from the queue. By running these methods in the FixedUpdate they are automatically ran on the main thread.","title":"Running Unity specific code on the main thread"},{"location":"UnityIntegration/running-unity-specific-code-on-the-main-thread/#running-unity-specific-code-on-the-main-thread","text":"We have created a helper class for you to be able to offload any logic to the main thread from a separate thread. This helper class is called MainThreadManager and there are 2 main ways that you can use this class. The entry point for both methods of use is the static method Run ; see the code snippets below for practical uses. The examples below emulate an RPC method's contents.","title":"Running Unity specific code on the main thread"},{"location":"UnityIntegration/running-unity-specific-code-on-the-main-thread/#mainthreadmanagerrun-function-pointer","text":"public override void MyCustomRPC(object[] args) { // Register the private function within this class to be called on the main thread MainThreadManager.Run(OtherFunction); } private void OtherFunction() { Debug.Log( Hello World! ); } You can see that the above example requires another accessible method in order to pass it into the main thread manager's Run method.","title":"MainThreadManager.Run Function Pointer"},{"location":"UnityIntegration/running-unity-specific-code-on-the-main-thread/#mainthreadmanagerrun-lambda-expression","text":"public override void MyCustomRPC(object[] args) { // Setup a temporary method call (lambda expression) to be executed on the main thread MainThreadManager.Run(() = { Debug.Log( Hello World! ); }); } The above is the preferred method The lambda expression is a native C# feature that allows you to essentially create an inline function at runtime. Please see this website or the official documentation for more information on lambda expressions. What does the Main Thread Manager do? The Main Thread Manager is actually a pretty small and simple singleton class. When you send a method pointer or inline expression into the Run method it will be added to a queue. The Main Thread Manager is a Unity GameObject and will automatically create itself if one is not created already. Every FixedUpdate for this object, it will check to see if there are any pending methods in the queue, if so it will run them and remove them from the queue. By running these methods in the FixedUpdate they are automatically ran on the main thread.","title":"MainThreadManager.Run Lambda Expression"},{"location":"UnityIntegration/threading-in-unity/","text":"Threading in Unity If you have dealt with threading before and attempted to use it within Unity, then you probably know by now that you are not able to access the native Unity features from any thread other than the main thread . This does raise a bit of a complication when it comes to a completely multithreaded system such as Forge Networking. We've decided that running only on the main thread restricts our users and ourselves from achieving the full potential in performance that we would like. For this reason, we allow the user to manage how code is offloaded to the main thread in their applications. What is threading? If you are familiar with threading then you can skip this section. This is not going to be a complicated explanation of what the processor is doing at a hardware level but a simple abstract explanation so that it is not such an unfamiliar topic. I'm sure by now we are all familiar with machines that say things like dual-core or quad-core or octa-core etc. Imagine if you will that the machine has 2 cpu chips when we say dual core if this were the case, you could also imagine that you can run 2 things at the same exact time. This works much like if you hired someone to fold papers, if you hired a second person to fold papers at the same time, then you could get twice the work done in the same amount of time at the same exact time. Now lets imagine that the papers were a variable such as an int, what if both employees finished folding a paper at the same exact time and they both reached for the next paper in the stack? Well only one person can alter one paper at a time, you could wind up with the paper being folded twice! Now that you have that basic understanding of a simple issue that comes up with parallel computing (threading) you can say, \"what if unity messes with the game object, but I do at the same time?\". Of course no good will come out of this, this is precisely why Unity does not allow you to manipulate Unity objects from an external thread. There are probably a large number of reasons that Unity has chosen not to simply allow you to lock a mutex, but I digress. For this reason, we have created a helper class named MainThreadManager which we will talk more in depth in a later section. NOTE: Many modern CPUs can have multiple threads per core, for example the i7-6700K has 2 threads per core making a 4 core processor with 8 threads. What runs on a separate thread in Forge? In forge we have 2 critical threads for both the client and the server, and 1 extra critical thread for the server (in TCP mode). When in TCP mode the special thread that the server runs is the connection thread. This thread listens for new client connections and will begin the acceptance process from here. The other 2 threads that are shared on client and server, UDP and TCP, is the write and read threads. There is one long lived thread that is used for the reading of network messages. This reading thread will also execute RPC methods, read message events, and so forth. Almost everything that is processed on the network can be traced back to the read thread. The second thread, the write thread, is shared for all players. This thread is shared so that it can support thousands of connections/players at a time on lower end CPUs. This thread is an on-demand thread. It starts up when messages are being sent, and it shuts down when there are no more messages being sent. The client also uses the same write thread logic, however it is not as active as the server write thread for obvious reasons (it only communicates with the server and nobody else). Currently the only network communication that you need to worry about as an end user that gets called on a separate thread is an RPC.","title":"Threading in Unity"},{"location":"UnityIntegration/threading-in-unity/#threading-in-unity","text":"If you have dealt with threading before and attempted to use it within Unity, then you probably know by now that you are not able to access the native Unity features from any thread other than the main thread . This does raise a bit of a complication when it comes to a completely multithreaded system such as Forge Networking. We've decided that running only on the main thread restricts our users and ourselves from achieving the full potential in performance that we would like. For this reason, we allow the user to manage how code is offloaded to the main thread in their applications. What is threading? If you are familiar with threading then you can skip this section. This is not going to be a complicated explanation of what the processor is doing at a hardware level but a simple abstract explanation so that it is not such an unfamiliar topic. I'm sure by now we are all familiar with machines that say things like dual-core or quad-core or octa-core etc. Imagine if you will that the machine has 2 cpu chips when we say dual core if this were the case, you could also imagine that you can run 2 things at the same exact time. This works much like if you hired someone to fold papers, if you hired a second person to fold papers at the same time, then you could get twice the work done in the same amount of time at the same exact time. Now lets imagine that the papers were a variable such as an int, what if both employees finished folding a paper at the same exact time and they both reached for the next paper in the stack? Well only one person can alter one paper at a time, you could wind up with the paper being folded twice! Now that you have that basic understanding of a simple issue that comes up with parallel computing (threading) you can say, \"what if unity messes with the game object, but I do at the same time?\". Of course no good will come out of this, this is precisely why Unity does not allow you to manipulate Unity objects from an external thread. There are probably a large number of reasons that Unity has chosen not to simply allow you to lock a mutex, but I digress. For this reason, we have created a helper class named MainThreadManager which we will talk more in depth in a later section. NOTE: Many modern CPUs can have multiple threads per core, for example the i7-6700K has 2 threads per core making a 4 core processor with 8 threads. What runs on a separate thread in Forge? In forge we have 2 critical threads for both the client and the server, and 1 extra critical thread for the server (in TCP mode). When in TCP mode the special thread that the server runs is the connection thread. This thread listens for new client connections and will begin the acceptance process from here. The other 2 threads that are shared on client and server, UDP and TCP, is the write and read threads. There is one long lived thread that is used for the reading of network messages. This reading thread will also execute RPC methods, read message events, and so forth. Almost everything that is processed on the network can be traced back to the read thread. The second thread, the write thread, is shared for all players. This thread is shared so that it can support thousands of connections/players at a time on lower end CPUs. This thread is an on-demand thread. It starts up when messages are being sent, and it shuts down when there are no more messages being sent. The client also uses the same write thread logic, however it is not as active as the server write thread for obvious reasons (it only communicates with the server and nobody else). Currently the only network communication that you need to worry about as an end user that gets called on a separate thread is an RPC.","title":"Threading in Unity"},{"location":"WebServer/command-plugins/","text":"Web Server Command Plugins As you know by now, the webserver comes with a fancy console which allows you to type in commands and execute some logic on your server. One thing that we thought would be needed is for you to have the ability to create your own commands. Create the plugin class When creating a plugin for the webserver, you will need to derive from the ICommandPlugin interface which is in the BeardedManStudios.Forge.MVCWebServer.Plugins namespace, so be sure to add it to your using statements. Below you will see a code example of a plugin. This plugin must have the Execute method and it must return a string as well as take in a string[] of commands. If you typed into the command box testing brent farris the output would be Hello Brent! . However if you typed in testing \"Brent Farris\" the output would be Hello Brent Farris! . As you can see, the quotes will group parts of the command together. Lastly, parameters are not required (because of how we wrote our class) so testing by itself will respond with HELLO! . public class TestingPlugin : ICommandPlugin { public string Execute(string[] commands) { if (commands == null || commands.Length == 0) return HELLO! ; return Hello + commands[0] + ! ; } } Add our plugin Adding a plugin is very easy, let's say you have a web server running, all you need to do is call the TryAddPlugin method. Below is a couple examples of this in action. Without help strings ForgeWebServer ws = new ForgeWebServer(server, 15942, dict); ws.Start(); ws.TryAddPlugin( testing , new TestingPlugin()); With help strings ForgeWebServer ws = new ForgeWebServer(server, 15942, dict); ws.Start(); ws.TryAddPlugin( testing , new TestingPlugin(), Do a test log , testing brent , arg1 , arg2 , arg3 , ... ); When you supply help strings, then when you type help into the command box, it will print out the help messages to let the user know what the command does and what arguments it expects. Done Well that is it, once you create the command class and implement the ICommandPlugin interface, then do a call to TryAddPlugin with your plugin class, then you are ready to start using the command in the web browser. Notes You can create and add plugins to your web server at any time in your code. So you can potentially create commands to spawn objects, kill player characters, render a cube for no reason, pretty much anything you can imagine.","title":"Web Server Command Plugins"},{"location":"WebServer/command-plugins/#web-server-command-plugins","text":"As you know by now, the webserver comes with a fancy console which allows you to type in commands and execute some logic on your server. One thing that we thought would be needed is for you to have the ability to create your own commands.","title":"Web Server Command Plugins"},{"location":"WebServer/command-plugins/#create-the-plugin-class","text":"When creating a plugin for the webserver, you will need to derive from the ICommandPlugin interface which is in the BeardedManStudios.Forge.MVCWebServer.Plugins namespace, so be sure to add it to your using statements. Below you will see a code example of a plugin. This plugin must have the Execute method and it must return a string as well as take in a string[] of commands. If you typed into the command box testing brent farris the output would be Hello Brent! . However if you typed in testing \"Brent Farris\" the output would be Hello Brent Farris! . As you can see, the quotes will group parts of the command together. Lastly, parameters are not required (because of how we wrote our class) so testing by itself will respond with HELLO! . public class TestingPlugin : ICommandPlugin { public string Execute(string[] commands) { if (commands == null || commands.Length == 0) return HELLO! ; return Hello + commands[0] + ! ; } }","title":"Create the plugin class"},{"location":"WebServer/command-plugins/#add-our-plugin","text":"Adding a plugin is very easy, let's say you have a web server running, all you need to do is call the TryAddPlugin method. Below is a couple examples of this in action.","title":"Add our plugin"},{"location":"WebServer/command-plugins/#without-help-strings","text":"ForgeWebServer ws = new ForgeWebServer(server, 15942, dict); ws.Start(); ws.TryAddPlugin( testing , new TestingPlugin());","title":"Without help strings"},{"location":"WebServer/command-plugins/#with-help-strings","text":"ForgeWebServer ws = new ForgeWebServer(server, 15942, dict); ws.Start(); ws.TryAddPlugin( testing , new TestingPlugin(), Do a test log , testing brent , arg1 , arg2 , arg3 , ... ); When you supply help strings, then when you type help into the command box, it will print out the help messages to let the user know what the command does and what arguments it expects.","title":"With help strings"},{"location":"WebServer/command-plugins/#done","text":"Well that is it, once you create the command class and implement the ICommandPlugin interface, then do a call to TryAddPlugin with your plugin class, then you are ready to start using the command in the web browser.","title":"Done"},{"location":"WebServer/command-plugins/#notes","text":"You can create and add plugins to your web server at any time in your code. So you can potentially create commands to spawn objects, kill player characters, render a cube for no reason, pretty much anything you can imagine.","title":"Notes"},{"location":"WebServer/extending-with-mvc/","text":"Web Server Extending With MVC Yes, the web server is a full blown website in it's own right. Being this, you may want to add new controllers and views to the site. We'll start by making a controller named \"Test\". This will make it so that you can go to localhost:15942/test and have your own custom view processed and shown. Our custom \"Test\" controller public class Test : PageController { public Test(NetWorker socket, ForgeWebServer webserver) : base(socket, webserver) { // Key string used in html like this: % print % variables.Add( print , Print); } public string Print() { return HELLO TEST STRING ACTION! ; } public override string Render() { return PresentHTML( test ); } } As you can see from above, there are a lot of things going on, so we'll break them down one by one. 1. You must derive your new controller from the PageController class 2. You must create the constructor for your controller with the supplied input arguments 3. You should add any model pulling functions inside the constructor to the variables 4. You should create methods that are going to return the data needed for the variables 5. You must override the render method as it is abstract. This is where you return the HTML for your page. You can use the built in PresentHTML method you get from the parent class and pass in the name of your HTML page that will be presented. When you add callbacks assigned to a string to variables as seen above with print , you are making it so that you can use the string response from those callbacks within your HTML page. See the test.html example below to see how it is used in the % % tags. Now that you have your new controller, you are probably curious on how you can get it to be used while the web server is running. Below you will notice the line that has TryAddController which will try to add your new controller to the web server. Notice that all we have to do is new up the controller and pass it into this method. Adding your new controller ForgeWebServer ws = new ForgeWebServer(server, 15942, dict); ws.Start(); ws.TryAddController(new Test(server, ws)); Finally, we are ready to create our view. A view is something that the controller will present to the user when they request your controllers web page. We will name this file test.html because we are passing test into the PresentHTML of our controller. If we were to name this html file cats then we would need to update the controller to pass \"cats\" into the PresentHTML method of the Render function. Our \"test.html\" view html head title My Test Page /title /head body h1 Hello % print % /h1 /body /html Note if you are not sure what the HTML page is, be sure to check out the Jumpstart Guide Done That's it, you have your fancy new controller and view and you can start using it immediately inside of your web server.","title":"Web Server Extending With MVC"},{"location":"WebServer/extending-with-mvc/#web-server-extending-with-mvc","text":"Yes, the web server is a full blown website in it's own right. Being this, you may want to add new controllers and views to the site. We'll start by making a controller named \"Test\". This will make it so that you can go to localhost:15942/test and have your own custom view processed and shown.","title":"Web Server Extending With MVC"},{"location":"WebServer/extending-with-mvc/#our-custom-test-controller","text":"public class Test : PageController { public Test(NetWorker socket, ForgeWebServer webserver) : base(socket, webserver) { // Key string used in html like this: % print % variables.Add( print , Print); } public string Print() { return HELLO TEST STRING ACTION! ; } public override string Render() { return PresentHTML( test ); } } As you can see from above, there are a lot of things going on, so we'll break them down one by one. 1. You must derive your new controller from the PageController class 2. You must create the constructor for your controller with the supplied input arguments 3. You should add any model pulling functions inside the constructor to the variables 4. You should create methods that are going to return the data needed for the variables 5. You must override the render method as it is abstract. This is where you return the HTML for your page. You can use the built in PresentHTML method you get from the parent class and pass in the name of your HTML page that will be presented. When you add callbacks assigned to a string to variables as seen above with print , you are making it so that you can use the string response from those callbacks within your HTML page. See the test.html example below to see how it is used in the % % tags. Now that you have your new controller, you are probably curious on how you can get it to be used while the web server is running. Below you will notice the line that has TryAddController which will try to add your new controller to the web server. Notice that all we have to do is new up the controller and pass it into this method.","title":"Our custom \"Test\" controller"},{"location":"WebServer/extending-with-mvc/#adding-your-new-controller","text":"ForgeWebServer ws = new ForgeWebServer(server, 15942, dict); ws.Start(); ws.TryAddController(new Test(server, ws)); Finally, we are ready to create our view. A view is something that the controller will present to the user when they request your controllers web page. We will name this file test.html because we are passing test into the PresentHTML of our controller. If we were to name this html file cats then we would need to update the controller to pass \"cats\" into the PresentHTML method of the Render function.","title":"Adding your new controller"},{"location":"WebServer/extending-with-mvc/#our-testhtml-view","text":"html head title My Test Page /title /head body h1 Hello % print % /h1 /body /html Note if you are not sure what the HTML page is, be sure to check out the Jumpstart Guide","title":"Our \"test.html\" view"},{"location":"WebServer/extending-with-mvc/#done","text":"That's it, you have your fancy new controller and view and you can start using it immediately inside of your web server.","title":"Done"},{"location":"WebServer/jumpstart/","text":"Web Server Jumpstart Getting up and running with the web server is easier than ever. Just include the plugin into your project, new up the object and start/stop the server at will. The namespace for the web server is BeardedManStudios.Forge.MVCWebServer , so if you need to include using statements or view things in the object browser, take a look in this namespace. Including plugin into project You will notice a MVCWebServer.dll file in the unzipped folder for the web server. You just need to copy this file into your Bearded Man Studios Inc/Plugins folder. That is it, you've installed the web server plugin to your project. Starting a Web Server Starting a web server is as simple as calling 2 lines of code as seen below. ForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT); ws.Start(); I know what you are saying, \"what is server... and what are pages?\". Good questions; see below: - server : This is the NetWorker for the server - pages : This is a Dictionary string, string () of web pages (html). The key string is the name of the page, like \"index\" and the value is the html of the page. The pages you add here will be viewable from the web interface. So let's say you add a page cat and the html h1 Hello World /h1 . Then if you went to locahost:15942/cat in any web browser, you would see a big bold Hello World heading on the page. We have added a few default pages as part of the package in the Resources folder. If you want a magical function that automatically maps all the pages you put into this folder, well... here you go: string pathToFiles = fnwww/html ; Dictionary string, string pages = new Dictionary string, string (); TextAsset[] assets = Resources.LoadAll TextAsset (pathToFiles); foreach (TextAsset a in assets) pages.Add(a.name, a.text); ForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT); ws.Start(); // ... Stopping a Web Server When you are closing your connection/application that has a running web server, you will want to close the connection for the web server as well. You can see how to close the connection to the web server below: ForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT); ws.Start(); // ... ws.Stop(); Notices Warnings! STOP, BEFORE YOU LEAVE THIS PAGE! There are a few things to keep in mind when using the web server. 1. If you disconnect your server, you MUST disconnect your web server as well. Since this is a plugin system, you need to remember to do this. 2. You MUST remember to close the web server on application quit. 3. The commands are run on a separate thread so you need to use MainThreadManager for any code that requires to be on the main thread","title":"Web Server Jumpstart"},{"location":"WebServer/jumpstart/#web-server-jumpstart","text":"Getting up and running with the web server is easier than ever. Just include the plugin into your project, new up the object and start/stop the server at will. The namespace for the web server is BeardedManStudios.Forge.MVCWebServer , so if you need to include using statements or view things in the object browser, take a look in this namespace.","title":"Web Server Jumpstart"},{"location":"WebServer/jumpstart/#including-plugin-into-project","text":"You will notice a MVCWebServer.dll file in the unzipped folder for the web server. You just need to copy this file into your Bearded Man Studios Inc/Plugins folder. That is it, you've installed the web server plugin to your project.","title":"Including plugin into project"},{"location":"WebServer/jumpstart/#starting-a-web-server","text":"Starting a web server is as simple as calling 2 lines of code as seen below. ForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT); ws.Start(); I know what you are saying, \"what is server... and what are pages?\". Good questions; see below: - server : This is the NetWorker for the server - pages : This is a Dictionary string, string () of web pages (html). The key string is the name of the page, like \"index\" and the value is the html of the page. The pages you add here will be viewable from the web interface. So let's say you add a page cat and the html h1 Hello World /h1 . Then if you went to locahost:15942/cat in any web browser, you would see a big bold Hello World heading on the page. We have added a few default pages as part of the package in the Resources folder. If you want a magical function that automatically maps all the pages you put into this folder, well... here you go: string pathToFiles = fnwww/html ; Dictionary string, string pages = new Dictionary string, string (); TextAsset[] assets = Resources.LoadAll TextAsset (pathToFiles); foreach (TextAsset a in assets) pages.Add(a.name, a.text); ForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT); ws.Start(); // ...","title":"Starting a Web Server"},{"location":"WebServer/jumpstart/#stopping-a-web-server","text":"When you are closing your connection/application that has a running web server, you will want to close the connection for the web server as well. You can see how to close the connection to the web server below: ForgeWebServer ws = new ForgeWebServer(server, pages, ForgeWebServer.DEFAULT_PORT); ws.Start(); // ... ws.Stop();","title":"Stopping a Web Server"},{"location":"WebServer/jumpstart/#notices-warnings","text":"STOP, BEFORE YOU LEAVE THIS PAGE! There are a few things to keep in mind when using the web server. 1. If you disconnect your server, you MUST disconnect your web server as well. Since this is a plugin system, you need to remember to do this. 2. You MUST remember to close the web server on application quit. 3. The commands are run on a separate thread so you need to use MainThreadManager for any code that requires to be on the main thread","title":"Notices &amp; Warnings!"}]}